{"meta":{"title":"hrf12blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-03-09T10:05:52.862Z","updated":"2022-03-09T10:05:52.862Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"http://example.com/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"}],"posts":[{"title":"","slug":"04-JavaScript基础","date":"2022-03-09T09:49:27.180Z","updated":"2022-03-09T09:51:35.128Z","comments":true,"path":"2022/03/09/04-JavaScript基础/","link":"","permalink":"http://example.com/2022/03/09/04-JavaScript%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1.JavaScript基础##1.1 课外提示1.敲代码用指法,指法配图，坚持一周者即可熟练2.码农不需要练就一阳指或者二指禅3.可以使用金山打字通，此处并非打广告,个人建议，天天敲代码，不停的反复的敲练习和作业，速度和基本功的快速提升 windows中的常用快捷键 ##1.2 浏览器说明浏览器是指可以显示网页服务器或者文件系统的HTML文件内容，并让用户与这些文件交互的一种软件。通俗的讲:可以显示页面的一个软件,国内网民计算机上常见的网页浏览器有，QQ浏览器、Internet Explorer、Firefox、Safari，Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、傲游浏览器、世界之窗浏览器等，浏览器是最经常使用到的客户端程序。常用的五大浏览器：chrome，firefox，Safari，ie，opera我们用chrome(谷歌浏览器) 1.3 网页、网站和应用程序网页：单独的一个页面网站：一些列相关的页面组成到一起应用程序：可以和用户产生交互，并实现某种功能。 1.4 演示JavaScript的强大http://impress.github.io/impress.js/http://naotu.baidu.com/https://codecombat.com/https://ide.codemao.cn/ 需要翻墙https://developers.google.com/blockly/blockly迷宫https://blockly-games.appspot.com blockly迷宫不需要翻墙https://blockly.uieee.com/ 1.5 JavaScript介绍1.5.1 JavaScript是什么Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。Java和JavaScript的关系就像张雨和张雨生的关系，只是名字很像。 Java 服务器端的编程语言 JavaScript 运行在客户端(浏览器)的编程语言 JavaScript是一种运行在客户端* 的弱类型*脚本语言 ，是一种解释性动态类型的基于对象的语言。**JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 1.5.2 JavaScript最初的目的演示：http://baixiu.uieee.com/admin/login.php最初的目的是为了处理表单的验证操作。 1.5.3 Javascript的历史CEnvi的ScriptEase 当90年代 NetscapeNavigator 崭露头角时，Nombas 开发了一个可以嵌入网页中的 CEnvi 的版本。这些早期的试验被称为 Espresso Page（浓咖啡般的页面），它们代表了第一个在万维网上使用的客户端语言。而 Nombas 丝毫没有料到它的理念将会成为万维网的一块重要基石。 Netscape 发明了JavaScript 当网上冲浪越来越流行时，对于开发客户端脚本的需求也逐渐增大。此时，大部分因特网用户还仅仅通过 28.8 kbit&#x2F;s 的调制解调器连接到网络，即便这时网页已经不断地变得更大和更复杂。而更加加剧用户痛苦的是，仅仅为了简单的表单有效性验证，就要与服务器进行多次地往返交互。设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段。 那时正处于技术革新最前沿的 Netscape，开始认真考虑开发一种客户端脚本语言来解决简单的处理问题。 当时工作于 Netscape 的 Brendan Eich，开始着手为即将在 1995 年发行的 Netscape Navigator 2.0 开发一个称之为 LiveScript 的脚本语言，当时的目的是在浏览器和服务器（本来要叫它 LiveWire）端使用它。Netscape 与 Sun 及时完成LiveScript 实现。 就在 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript，目的是为了利用 Java 这个因特网时髦词汇。Netscape 的赌注最终得到回报，JavaScript从此变成了因特网的必备组件。 三足鼎立 因为 JavaScript 1.0 如此成功，Netscape 在 Netscape Navigator 3.0 中发布了 1.1 版。恰巧那个时候，微软决定进军浏览器，发布了 IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 JScript（这样命名是为了避免与 Netscape 潜在的许可纠纷）。微软步入 Web 浏览器领域的这重要一步虽然令其声名狼藉，但也成为 JavaScript 语言发展过程中的重要一步。 在微软进入后，有 3 种不同的 JavaScript 版本同时存在：Netscape Navigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。与 C 和其他编程语言不同的是，JavaScript并没有一个标准来统一其语法或特性，而这 3 种不同的版本恰恰突出了这个问题。随着业界担心的增加，这个语言的标准化显然已经势在必行。 标准化 1997 年，JavaScript 1.1 作为一个草案提交给欧洲计算机制造商协会（ECMA）。第 39 技术委员会（TC39）被委派来“标准化一个通用、跨平台、中立于厂商的脚本语言的语法和语义”(http://www.ecma-international.org/memento/TC39.htm)。由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39 锤炼出了 ECMA-262，该标准定义了名为 ECMAScript 的全新脚本语言。 在接下来的几年里，国际标准化组织及国际电工委员会（ISO&#x2F;IEC）也采纳 ECMAScript 作为标准（ISO&#x2F;IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将ECMAScript 作为 JavaScript 实现的基础。 1.5.4 JavaScript现在的意义(应用场景)JavaScript 发展到现在几乎无所不能。 网页特效 服务端开发(Node.js) 命令行工具(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) 1.5.5 JavaScript和HTML、CSS的区别 HTML：提供网页的结构，提供网页中的内容 CSS: 用来美化网页 JavaScript: 可以用来控制网页内容，给网页增加动态的效果 1.6 JavaScript的组成 1.6.1 ECMAScriptECMA 欧洲计算机制造联合会 网景：JavaScript 微软：JScript 定义了JavaScript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 1.6.2 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 1.6.3 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 1.7 JavaScript的书写位置 写在行内 1&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert(&#x27;Hello World&#x27;)&quot; /&gt; 写在script标签中 12345&lt;head&gt; &lt;script&gt; alert(&#x27;Hello World!&#x27;); &lt;/script&gt;&lt;/head&gt; 写在外部js文件中，在页面引入 1&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; 注意点 12345671.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行3.script的标签中可以写什么内容 type=&quot;text/javascript&quot;是标准写法或者写language=&quot;JavaScript&quot;都可以。但是,目前在我们的html页面中,type和language都可以省略,原因:html是遵循h5的标准4.有可能会出现这种情况:script标签中可能同时出现type和language的写法.5.script标签在页面中可以出现多对6.script标签一般是放在body的标签的最后的,有的时候会在head标签中,目前讲课的时候都在body标签的后面(body中的最后)7.如果script标签是引入外部js文件的作用,那么这对标签中不要写任何的js代码,如果要写,重新写一对script标签,里面写代码 1.8 计算机组成1.8.1 软件 应用软件：浏览器(Chrome&#x2F;IE&#x2F;Firefox)、QQ、Sublime、Word 系统软件：Windows、Linux、mac OSX 1.8.2 硬件 三大件：CPU、内存、硬盘 – 主板 输入设备：鼠标、键盘、手写板、摄像头等 输出设备：显示器、打印机、投影仪等 1.9 变量1.9.1 什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 1.9.2 如何使用变量 var声明变量 1var age; //js中声明变量都用var 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = &#x27;zs&#x27;; 同时声明多个变量并赋值 1var age = 10, name = &#x27;zs&#x27;; //单引号和双引号都可以表示字符串 1.9.3 变量在内存中的存储1var age = 18; 1.9.4 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 下面哪些变量名不合法 123456789a 1age1818agename$name_sex&amp;sextheworsd theWorsd 1.9.5 案例 交换两个变量的值 不使用临时变量，交换两个数值变量的值 123456789var num1 = 10;var num2 = 20;//把num1的变量中的值和num2变量中的值,取出来相加,重新赋值给num1这个变量num1 = num1 + num2;//30//num1变量的值和num2变量的值取出来,相减的结果重新赋值给num2num2 = num1 - num2;//10//num1变量的值和num2变量的值取出来,相减的结果重新赋值给num1num1 = num1 - num2;//20console.log(num1, num2); 1.10 数据类型1.10.1 基本数据类型Number、String、Boolean、Undefined、Null a) Number类型 数值字面量：数值的固定值的表示法 110 1024 60.5 进制 123456789101112131415161718二进制 var a = 0b111;十进制 var num = 9; console.log(num); 进行算数计算时，八进制和十六进制表示的数值最终都将被转换成十进制数值。十六进制 var num = 0xA; console.log(num); 数字序列范围：0~9以及A~F八进制 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 console.log(num3); 数字序列范围：0~7 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析 浮点数 浮点数的精度问题 1234567浮点数 var n = 5e-324; // 科学计数法 5乘以10的-324次方 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数 var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); 不要判断两个浮点数是否相等 数值范围 1234567891011121314最小值：Number.MIN_VALUE， JavaScript 中可表示的最小的数(接近 0,但不是负数)，这个值为： 5e-324最大值：Number.MAX_VALUE， JavaScript 中可表示的最大的数，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity&lt;script type=&quot;text/javascript&quot;&gt;var t1=1.7976931348623157E+10308document.write(t1)document.write(&quot;&lt;br /&gt;&quot;)var t2=-1.7976931348623157E+10308document.write(t2)&lt;/script&gt; 数值判断 NaN：not a number 1NaN 与任何值都不相等，包括他本身 isNaN: is not a number b) String类型‘abc’ “abc” 字符串字面量 ‘程序猿’，’程序媛’, “前端程序猿” 思考：如何打印以下字符串。 12我是一个&quot;正直&quot;的人 我很喜欢&quot;前端&#x27;程序猿&#x27;&quot; 转义符 字符串长度 length属性用来获取字符串的长度 12var str = &#x27;前端程序猿 Hello World&#x27;;console.log(str.length); 字符串拼接 字符串拼接使用 + 连接 1234567console.log(11 + 11);console.log(&#x27;hello&#x27; + &#x27; world&#x27;);console.log(&#x27;100&#x27; + &#x27;100&#x27;);console.log(&#x27;11&#x27; + 11); //拼接字符串console.log(&#x27;11&#x27; - 3); //隐式转换console.log(&#x27;11&#x27; * 3); //隐式转换console.log(&#x27;male:&#x27; + true); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 c) Boolean类型 Boolean字面量： true和false，区分大小写 计算机内部存储：true为1，false为0 d) Undefined和Null Undefined类型只有一个值，即undefined。undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined Null类型也只有一个值，即null。null表示一个空，null值表示一个空对象指针。变量的值如果想为null，必须手动设置 123456789101112131415161. 相同点 if 判断语句中，两者都会被转换为false2. 不同点 2.1 Number转换的值不同，Number(null)输出为0, Number(undefined)输出为NaN 2.2 null表示一个值被定义了，但是这个值是空值 2.3 undefined表示缺少值，即此处应该有值，但是还没有定义3.注意点： alert(typeof undefined); //output &quot;undefined&quot; alert(typeof null); //output &quot;object&quot; 第一行代码很容易理解，undefined的类型为Undefined；第二行代码却让人疑惑，为什么null的类型又是Object了呢？其实这是JavaScript最初实现的一个错误，后来被ECMAScript沿用下来。在今天我们可以解释为，null即是一个不存在的对象的占位符，但是在实际编码时还是要注意这一特性。4.ECMAScript认为undefined是从null派生出来的，所以把它们定义为相等的 alert(null == undefined); //output &quot;true&quot; 1.10.2 引用数据类型Object Function 1.10.3 获取变量的类型typeof 12var age = 18;console.log(typeof age); // &#x27;number&#x27; 1.10.4 字面量在源代码中一个固定值的表示法。 数值字面量：8, 9, 10 字符串字面量：’程序员’, “大前端” 布尔字面量：true，false 1.11 注释1.11.1 单行注释用来描述下面一个或多行代码的作用 12// 这是一个变量var name = &#x27;hm&#x27;; 1.11.2 多行注释用来注释多条代码 12345/*var age = 18;var name = &#x27;zs&#x27;;console.log(name, age);*/ 1.12 数据类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 1.12.1 转换成字符串类型 toString() 12var num = 5;console.log(num.toString()); String() 1234String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和nullvar num3=null;console.log(String(num3)); 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 1.12.2 转换成数值类型 Number() 1Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() 12var num1 = parseInt(&quot;12.3abc&quot;); // 返回12，如果第一个字符是数字会解析知道遇到非数字结束var num2 = parseInt(&quot;abc123&quot;); // 返回NaN，如果第一个字符不是数字或者符号就返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt非常相似，不同之处在与 parseFloat会解析第一个. 遇到第二个.或者非数字结束 如果解析的内容里只有整数，解析成整数 +，- ,0等运算 1234var str = &#x27;500&#x27;;console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); //先转换成数值，再进行运算 1.12.3 转换成布尔类型 Boolean() 10 &#x27;&#x27;(空字符串) null undefined NaN 会转换成false 其它都会转换成true 1.13 操作符1.13.1 算术运算符1+ - * / % 1.13.2 一元运算符一元运算符：只有一个操作数的运算符 5 + 6 两个操作数的运算符 二元运算符 ++ 自身加1 – 自身减1 前置++ 12345var num1 = 5;++ num1; var num2 = 6;console.log(num1 + ++ num2); 后置++ 1234var num1 = 5;num1 ++; var num2 = 6 console.log(num1 + num2 ++); 猜猜看 1234var a = 1; var b = ++a + ++a; console.log(b); var a = 1; var b = a++ + ++a; console.log(b); var a = 1; var b = a++ + a++; console.log(b); var a = 1; var b = ++a + a++; console.log(b); 总结前置++：先加1，后参与运算后置++：先参与运算，后加1上面两个理解后，下面两个自通前置– ：先减1，后参与运算后置– ：先参与运算，后减1 1.13.3 逻辑运算符(布尔运算符)逻辑运算符与（&amp;）、或（|）、非（！）、异或（^）及双与（&amp;&amp;）和双或（||） 12345&amp;&amp; 与 两个操作数同时为true，结果为true，否则都是false|| 或 两个操作数有一个为true，结果为true，否则为false! 非 取反注意短路效果！ a) 双与和单与123456789101112131415true &amp; true = truetrue &amp; false = falsefalse &amp; false = falsefalse &amp; true = trueint x = 3;int y = 4;//System.out.println((++x == 3) &amp; (++y == 4)); //false &amp; false = false//System.out.println(&quot;x = &quot; + x); //x = 4//System.out.println(&quot;y = &quot; + y); //y = 5System.out.println(&quot;---------------------------&quot;);System.out.println((++x == 3) &amp;&amp; (++y == 4)); //false &amp; false = falseSystem.out.println(&quot;x = &quot; + x); //x = 4System.out.println(&quot;y = &quot; + y); //y = 4 b) 位运算符按位操作符用来操作整数基本数据类型中的单个比特（bit），就是二进制，按位操作符会对两个参数中对应的位（bit）执行布尔运算，最终生成一个结果。按位操作符来源于C语言面向底层的操作，Java设计的初衷是嵌入式电视机机顶盒，所以面向底层的操作也保留了下来。 任何信息在计算机中都是以二进制的形式保存的，”&amp;”、“|”、“^”除了可以作为逻辑运算符也可以作为位运算符。位运算是直接对二进制进行运算。他们对两个操作数中的每一个二进制位都进行运算。例如int是由32个二进制数组成，因此使用位运算符可以对整数值的二进制数进行运算。 位（bit）运算符： &amp; 与（AND） | 或（OR） ^ 异或 规则： 1234可以把1当做true 0当做false只有参与运算的两位都为1，&amp;运算的结果才为1，否则就为0。 只有参加运算的两位都是0，| 运算的结果才是0，否则都是1。只有参加运算的两位不同，^运算的结果才为1，否则就为0。 00000110 6 00000011 3 00000010 6 &amp; 3 &#x3D;2 00000110 6 00000011 3 00000111 6|3 &#x3D;7 00000110 6 00000011 3 00000101 6^3 &#x3D;5 1234567//使用异或交换两个变量的值var num1 = 10;var num2 = 20;num1 = num1 ^ num2; num2 = num1 ^ num2;num1 = num1 ^ num2;console.log(num1, num2); c) 移位操作符&lt;&lt;左移 &gt;&gt;右移 运算符 运算 范例 &lt;&lt; 左移 3 &lt;&lt; 2 &#x3D; 12 –&gt; 3*2*2&#x3D;12 &gt;&gt; 右移 3 &gt;&gt; 1 &#x3D; 1 –&gt; 3&#x2F;2&#x3D;1 1.13.4 关系运算符(比较运算符)&lt; &gt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D; 12345==与===的区别：==只进行值得比较，===类型和值同时相等，则相等var result = &#x27;55&#x27; == 55; // truevar result = &#x27;55&#x27; === 55; // false 值相等，类型不相等var result = 55 === 55; // true 1.13.5 赋值运算符&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; 123例如：var num = 0;num += 5; //相当于 num = num + 5; 1.13.6 运算符的优先级优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 12345678// 练习1：4 &gt;= 6 || &#x27;人&#x27; != &#x27;阿凡达&#x27; &amp;&amp; !(12 * 2 == 144) &amp;&amp; true// 练习2：var num = 10;5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === &#x27;22&#x27; 1.13.7 三元运算符123表达式1 ? 表达式2 : 表达式3是对if……else语句的一种简化写法 案例： 是否年满18岁 从两个数中找最大值 1.14 流程控制语句 程序的三种基本结构 1.14.1 流程控制介绍流程控制可以分为三种结构，分别是：顺序结构、分支结构、循环结构 1.14.2 分支结构a) if语句语法结构 12345678910111213141516171819if (/* 条件表达式 */) &#123; // 执行语句&#125;if (/* 条件表达式 */)&#123; // 成立执行语句&#125; else &#123; // 否则执行语句&#125;if (/* 条件1 */)&#123; // 成立执行语句&#125; else if (/* 条件2 */)&#123; // 成立执行语句&#125; else if (/* 条件3 */)&#123; // 成立执行语句&#125; else &#123; // 最后默认执行语句&#125; 案例： 求两个数的最大数 判断一个数是偶数还是奇数 分数转换，把百分制转换成ABCDE &lt;60 E 60-70 D 70-80 C 80-90 B 90 - 100 A作业： 判断一个年份是闰年还是平年 闰年：能被4整除，但不能被100整除的年份 或者 能被400整除的年份 判断一个人的年龄是否满18岁(是否成年) 注意点：在if else if else if结构中只有一种情况会被执行 c) switch语句语法格式: 123456789101112131415161718switch (expression) &#123; case 常量1: 语句; break; case 常量2: 语句; break; case 常量3: 语句; break; … case 常量n: 语句; break; default: 语句; break;&#125; break可以省略，如果省略，代码会继续执行下一个case switch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串&#39;10&#39; 不等于数值 10） 案例： 输入1~7的数组，显示星期几 &#x2F;&#x2F; var num&#x3D;parseInt(prompt(“请输入一个星期的数字”)); 输入月份显示月份的天数 12345678910111213# 注意点：流程控制语句会把后面的值隐式转换成布尔类型转换为true 非空字符串 非0数字 true 任何对象转换成false 空字符串 0 false null undefined// 结果是什么？var a = !&#x27;123&#x27;;var message;// 会自动把message转换成falseif (message) &#123; // todo...&#125; 1.14.3 循环结构 在javascript中，循环语句有三种，while、do..while、for循环。 a) while语句基本语法： 12345// 当循环条件为true时，执行循环体，// 当循环条件为false时，结束循环。while (循环条件) &#123; //循环体&#125; 代码示例： 123456789101112// 计算1-100之间所有数的和// 初始化变量var i = 1;var sum = 0;// 判断条件while (i &lt;= 100) &#123; // 循环体 sum += i; // 自增 i++;&#125;console.log(sum); 案例： 打印100以内 7的倍数 打印100以内所有偶数 打印100以内所有偶数的和作业： 打印100以内的奇数 打印100以内的奇数的和 b) do…while语句 do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。 基础语法： 123do &#123; // 循环体;&#125; while (循环条件); 代码示例： 1234567// 初始化变量var i = 1;var sum = 0;do &#123; sum += i;//循环体 i++;//自增&#125; while (i &lt;= 100);//循环条件 案例： 12求100以内所有3的倍数的和使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):&quot;，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 c) for语句 while和do…while一般用来解决无法确认次数的循环。for循环一般在循环次数确定的时候比较方便 for循环语法： 1234// for循环的表达式之间用的是;号分隔的，千万不要写成,for (初始化表达式1; 判断表达式2; 自增表达式3) &#123; // 循环体4&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成false) 初始化表达式 判断表达式 自增表达式 循环体 案例： 1234567891011121314151617181920212223242526272829303132333435363738391.打印1-100之间所有数2.求1-100之间所有数的和3.求1-100之间所有数的平均值4.求1-100之间所有偶数的和5.同时求1-100之间所有偶数和奇数的和6.打印正方形// 使用拼字符串的方法的原因// console.log 输出重复内容的问题// console.log 默认输出内容介绍后有换行7.打印10行10列星号var start = &#x27;&#x27;;for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; start += &#x27;* &#x27;; &#125; start += &#x27;\\n&#x27;;&#125;console.log(start);8.打印直角三角形var start = &#x27;&#x27;;for (var i = 0; i &lt; 10; i++) &#123; for (var j = i; j &lt; 10; j++) &#123; start += &#x27;* &#x27;; &#125; start += &#x27;\\n&#x27;;&#125;console.log(start);9.打印9*9乘法表var str = &#x27;&#x27;;for (var i = 1; i &lt;= 9; i++) &#123; for (var j = i; j &lt;=9; j++) &#123; str += i + &#x27; * &#x27; + j + &#x27; = &#x27; + i * j + &#x27;\\t&#x27;; &#125; str += &#x27;\\n&#x27;;&#125;console.log(str); 作业： 1234567891011121314151617181920212223242526272829303132333435363738394041424344451.求1-100之间所有数的乘积var sum=1;for(var i=1;i&lt;=100;i++)&#123; sum=sum*i&#125;console.log(sum);2.求1-100之间所有奇数的和var sum=0;for(var i=1;i&lt;=100;i++)&#123; if(i%2!=0)&#123; sum+=i; &#125;&#125;console.log(sum)3.计算1-100之间能3整除的数的和var sum=0;for(var i=1;i&lt;=100;i++)&#123; if(i%3=0)&#123; sum+=i; &#125;&#125;console.log(sum)4.计算1-100之间不能被7整除的数的和var sum=0;for(var i=1;i&lt;=100;i++)&#123; if(i%7!=0)&#123; sum+=i; &#125;&#125;console.log(sum)// 讲解思路。如果不会写程序，可以先把数学公式准备好5.本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？var money=10000;for(var i=1;i&lt;=5;i++)&#123; money=money*(1+0.003)&#125;console.log(money);6.有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？（兔子的规律为数列，1，1，2，3，5，8，13，21） var num1 = 0, num2 = 1, temp; var arr = new Array(12); for (i = 2; i &lt;= 12; i++) &#123; temp = num2; num2 += num1; num1 = temp; arr[0] = 1; arr[i - 1] = num2; &#125; console.log(arr) d) continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 案例： 12求整数1～100的累加值，但要求碰到个位为3的数则停止累加求整数1～100的累加值，但要求跳过所有个位为3的数 作业： 求1-100之间不能被7整除的整数的和（用continue）求200-300之间所有的奇数的和（用continue）求200-300之间第一个能被7整数的数（break） e) 调试 过去调试JavaScript的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤 1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作 123Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips: 监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。 1.15 数组1.15.1 数组介绍之前学习的数据类型，只能存储一个值(比如：Number&#x2F;String。我们想存储班级中所有学生的姓名，此时该如何存储？ 所谓数组，就是将多个元素（可以是不同类型的数据）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组是一个有序的列表，可以在数组中存放任意的数据，并且数组的长度可以动态的调整。 12345678910111213141516// 创建一个空数组var arr = new Array();var arr1 = []; // 创建一个有长度的数据var arr4 = new Array(4); //arr4数组长度为4，里面每一个元素都是undefined// 创建一个包含3个数值的数组，多个数组项以逗号隔开var arr2 = [1, 3, 4]; // 创建一个包含2个字符串的数组var arr3 = [&#x27;a&#x27;, &#x27;c&#x27;]; // 可以通过数组的length属性获取数组的长度console.log(arr3.length);// 可以设置length属性改变数组中元素的个数arr3.length = 0; 1.15.2 获取数组元素数组的取值 123456// 格式：数组名[下标] 下标又称索引// 功能：获取数组对应下标的那个值，如果下标不存在，则返回undefined。var arr = [&#x27;red&#x27;,, &#x27;green&#x27;, &#x27;blue&#x27;];arr[0]; // redarr[2]; // bluearr[3]; // 这个数组的最大下标为2,因此返回undefined 1.15.3 遍历数组 遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。 数组遍历的基本语法： 123for(var i = 0; i &lt; arr.length; i++) &#123; // 数组遍历的固定结构&#125; 1.15.4 数组中新增元素数组的赋值 1234567// 格式：数组名[下标/索引] = 值;// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];// 把red替换成了yellowarr[0] = &quot;yellow&quot;;// 给数组新增加了一个pink的值arr[3] = &quot;pink&quot;; 1.15.5 案例123456781.求一组数中的所有数的和 和平均值2.求一组数中的最大值和最小值，以及所在位置3.将字符串数组用|或其他符号分割 var names=[&quot;卡卡西&quot;,&quot;佐助&quot;,&quot;鸣人&quot;,&quot;大蛇丸&quot;,&quot;雏田&quot;,&quot;小苏&quot;,&quot;凤姐&quot;,&quot;黑崎一护&quot;];4.要求将数组中的0项去掉，将不为0的值存入一个新的数组，生成新的数组5.反转数组6.提示用户输入班级人数,求总成绩,平均值,最高分,最低分 parseInt(prompt(&quot;请输入班级人数&quot;)) 1.15.6 数组排序 https://www.cnblogs.com/liyongshuai/p/7197962.html 1.15.7 数组查找 返回下标1.15.8 二分法查找12345678910111213141516171819//二分法查找的前提，数组需要是有序的function getIndex(arr,num)&#123; var len = arr.length, st = 0, end = len-1 while(st&lt;=end)&#123; var mid = Math.floor((st+end)/2) if(num==arr[mid])&#123; return mid &#125;else if(num&gt;arr[mid])&#123; st = mid+1 &#125;else&#123; end = mid-1 &#125; &#125; return arr;&#125;var ary=[1,4,7,8,12,34,67,88,99,100] 1.16 函数1.16.1 函数介绍 如果要在多个地方求1-100之间所有数的和，应该怎么做？ 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名），在后续开发中可以反复调用 函数的作用就是封装一段代码，将来可以重复使用 1.16.2 函数的定义 函数声明 123function 函数名()&#123; // 函数体&#125; 函数表达式(匿名函数) 123var fn = function() &#123; // 函数体&#125; 特点： 函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 tellStory sayHello等 1.16.3 函数的调用 调用函数的语法： 1函数名(); 特点： 函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log(&quot;吃了没？&quot;);&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 1.16.4 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法： 12345678// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参...)&#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;//x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 1.16.5 案例 求1-n之间所有数的和 求n-m之间所有数额和 圆的面积 求2个数中的最大值 求3个数中的最大值 判断一个数是否是素数 1.16.6 函数的返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参...)&#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3); 函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。 返回值详解： 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined 如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值 如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined 函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。 1.16.7 案例 求阶乘 求1!+2!+3!+….+n! 求一组数中的最大值 求一组数中的最小值 1.16.8 arguments的使用 JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参。arguments是一个伪数组，因此及可以进行遍历 案例12求任意个数的最大值求任意个数的和 1.16.9 案例1234561.求斐波那契数列Fibonacci中的第n个数是多少？ 1 1 2 3 5 8 13 21...2.翻转数组，返回一个新数组3.对数组排序，从小到大4.输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]5.输入某年某月某日，判断这一天是这一年的第几天？6.和电脑猜拳10次(电脑出拳用随机数)，显示每次结果，最后累计输赢平局结果 1.16.10 代码规范1.命名规范 2.变量规范 var name = &#39;zs&#39;; 3.注释规范 // 这里是注释 4.空格规范 5.换行规范 var arr = [1, 2, 3, 4]; if (a &gt; b) &#123; &#125; for(var i = 0; i &lt; 10; i++) &#123; &#125; function fn() &#123; &#125; 1.18 作用域作用域：变量可以起作用的范围 1.18.1 全局变量和局部变量 全局变量 在任何地方都可以访问到的变量就是全局变量，对应全局作用域。在函数外声明。 局部变量 只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域) 12不使用var声明的变量是隐式全局变量，不推荐使用。变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁 1.18.2 块级作用域任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。在es5之前没有块级作用域的的概念,只有函数作用域，现阶段可以认为JavaScript没有块级作用域 1.18.3 词法作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析：声明会被提升，赋值不会提升 如果当前作用规则中有名字了, 就不考虑外面的名字 123456789101112131415161718192021var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ???假设JavaScript采用静态作用域，让我们分析下执行过程：执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。假设JavaScript采用动态作用域，让我们分析下执行过程：执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 1.18.4 作用域链只有函数可以制造作用域结构。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 作用域链:变量的使用,从里向外,层层的搜索,搜索到了就可以直接使用了。层层搜索,搜索到0级作用域的时候,如果还是没有找到这个变量,结果就是报错 1234567891011// 案例1：function f1() &#123; function f2() &#123; &#125;&#125;var num = 456;function f3() &#123; function f4() &#123; &#125;&#125; 12345678910// 案例2function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 1234567891011var num=10; //作用域链 级别:0var num2=20;function f1() &#123; var num2=30; function f2() &#123; var num3=30; console.log(num); &#125; f2();&#125;f1(); 1.19 预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 函数声明和变量声明都会置顶，但是变量声明位于函数声明之后 1234567891011121314151617// 1、变量的提升var num = 10;fun();function fun() &#123; console.log(num); var num = 20;&#125;//2、函数的提升var a = 18;f1();function f1() &#123; var b = 9; console.log(a); console.log(b); var a = &#x27;123&#x27;;&#125; 1234567891011121314151617181920212223242526//隐式全局变量的注意点f2();console.log(c);console.log(b);console.log(a);function f2() &#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125;等效于function f2() &#123; var a; //局部变量 a = 9; b = 9; //隐式全局变量 c = 9; //隐式全局变量 console.log(a); //9 console.log(b); //9 console.log(c); //9&#125;f2();console.log(c); //9console.log(b); //9console.log(a); //undefined 因为a是局部变量 12345678910//隐式全局变量的进一步说明var a = 18;b = 10;console.log(b);delete b;console.log(b); //此处会报错，原因隐式全局变量的声明是可以通过delete关键字删除的。删除之后就没有b的定义，无法console.log()delete a; //全局变量是不可以delete的，此处delete无效console.log(a); 1234567891011121314151617//函数提升在前，变量提升在后var a = 3;function a()&#123; console.log(10);&#125; console.log(a);a();//提升的时候，变量声明位于函数之后等效于：function a()&#123; console.log(10)&#125; //前var a; //后a = 3;console.log(a); //3a(); //not function 12345678910111213141516171819202122232425//函数中出现和全局变量同名的变量 以及if中出现和全局变量同名的变量的处理方式var tmp = new Date();function f()&#123; console.log(tmp); if(false)&#123; var tmp = &quot;hello&quot;; &#125;&#125;f();等效为：var tmp = new Date();function f()&#123; var tmp; console.log(tmp); if(false)&#123; tmp = &quot;hello&quot;; &#125;&#125;f();因为变量申明是在任意代码执行前处理的，在代码区中任意地方申明变量和在最开始（最上面）的地方申明是一样的。也就是说，看起来一个变量可以在申明之前被使用！这种行为就是所谓的“hoisting”，也就是变量提升，看起来就像变量的申明被自动移动到了函数或全局代码的最顶上。注意：仅仅是申明提升了，定义并不会被提升。 1234567891011121314151617181920//函数中出现和全局变量同名的变量 以及if中出现和全局变量同名的变量的处理方式var x = 1;console.log(x);if(true)&#123; var x = 2; console.log(x);&#125;console.log(x);等效为var x = 1;console.log(x);if(true)&#123; x = 2; console.log(x);&#125;console.log(x);js的var变量只有全局作用域和函数作用域两种，且申明会被提升，因此实际上x只会在最顶上开始的地方申明一次，var x=2的申明会被忽略，仅用于赋值。也就是说上面的代码实际上跟下面是一致的。 123456//匿名函数不存在预解析的问题f1();//-----报错var f1=function () &#123; console.log(a); var a=10;&#125;; 1.20 对象1.20.1 什么是对象12345678面向过程：关注的是问题解决的步骤，注重过程 吃---&gt;狗屎面向对象：关注的是问题解决的主体，注重结果 狗---&gt;吃屎现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。举例： 一部车，一个手机车是一类事物，门口停的那辆车才是对象 特征：红色、四个轮子 行为：驾驶、刹车 1.20.2 JavaScript中的对象123456JavaScript中的对象其实就是生活中对象的一个抽象JavaScript的对象是无序属性的集合。 其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。对象的行为和特征 特征---属性 行为---方法 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 1.20.3 对象创建方式 对象字面量 12345678910var o = &#123; name: &#x27;zs&#x27;, age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; //其实这种方法内部会自动调用new Object()方法来创建对象 new Object()创建对象 123456789var person = new Object();person.name = &#x27;lisi&#x27;;person.age = 35;person.job = &#x27;actor&#x27;;person.sayHi = function()&#123; console.log(&#x27;Hello,everyBody&#x27;);&#125;//缺点：每创建一个对象都要写一堆代码，太麻烦 工厂函数创建对象12345678910111213function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log(&#x27;Hello,everyBody&#x27;); &#125; return person;&#125;var p1 = createPerson(&#x27;张三&#x27;, 22, &#x27;actor&#x27;);//缺点：无法判断所创建出来的对象的具体类型 instanceof 自定义构造函数123456789101112//构造函数首字母大写function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log(&#x27;Hello,everyBody&#x27;); &#125;&#125;var p1 = new Person(&#x27;张三&#x27;, 22, &#x27;actor&#x27;);//好处：既封装了内部实现，又能通过instanceof来判断所创建出来对象的具体类型 1.20.4 属性和方法 如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征 如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能 1.20.5 练习12练习:有一个黄色的小狗,叫大黄,今年已经三岁了,250斤的重量每次走路都很慢,喜欢吃大骨头练习:创建一个手机对象,手机有型号,有颜色,可以打电话和发短信 1.20.6 new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new 会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 1.20.7 设置和获取属性的另一种写法123456789101112131415function Person(name,age) &#123; this.name=name; this.age=age; this.play=function () &#123; console.log(&quot;喜欢玩游戏&quot;); &#125;;&#125;var obj = new Person(&quot;卡卡西&quot;,20);//obj.name=&quot;佐助&quot;;obj[&quot;name&quot;]=&quot;佐助&quot;;console.log(obj[&quot;name&quot;]);obj.play();obj[&quot;play&quot;](); 1.20.8 遍历对象的属性 通过for..in语法可以遍历一个对象 12345678var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; //因为此时遍历到的key是一个字符串，需要通过obj[key]的方式才能访问内容 console.log(key + &quot;==&quot; + obj[key]);&#125; 1.20.9 删除对象的属性1234567function fun() &#123; this.name = &#x27;mm&#x27;;&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 1.20.10 简单类型和复杂类型的区别浅谈js内存：https://www.jianshu.com/p/396c110378db 基本类型又叫做值类型，复杂类型又叫做引用类型 值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。 引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。 堆和栈 123堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。 注意：JavaScript中没有堆和栈的概念，此处我们用堆和栈来讲解，目的方便理解和方便以后的学习。 a) 基本类型在内存中的存储 b) 复杂类型在内存中的存储 c) 基本类型作为函数的参数 d) 复杂类型作为函数的参数 https://www.cnblogs.com/liuyushao/p/6875341.html 123456789101112131415// 下面代码输出的结果function Person(name,age,salary) &#123; this.name = name; this.age = age; this.salary = salary;&#125;function f1(person) &#123; person.name = &quot;ls&quot;; person = new Person(&quot;aa&quot;,18,10);&#125;var p = new Person(&quot;zs&quot;,18,1000);console.log(p.name);f1(p);console.log(p.name); 思考： 1234567891011121314151617181920212223242526272829303132//1. var num1 = 10;var num2 = num1;num1 = 20;console.log(num1);console.log(num2);//2. var num = 50;function f1(num) &#123; num = 60; //此函数内部有一个变量num，修改的是当前函数内部的num console.log(num);&#125;f1(num);console.log(num);//3. var num1 = 55;var num2 = 66;function f1(num, num1) &#123; num = 100; num1 = 100; num2 = 100; console.log(num); console.log(num1); console.log(num2);&#125;f1(num1, num2);console.log(num1);console.log(num2);console.log(num); e) 值传递和址传递12345678910//值传递var a = 1;var b = 2;function changeA(a,b)&#123; var tmp = a; a = b; b = tmp;&#125;changeA(a,b);console.log(a,b); 123456789//址传递var a = [1,2];function changeB(a)&#123; var tmp = a[0]; a[0] = a[1]; a[1] = tmp;&#125;changeB(a);console.log(a); 1.20.11 练习一个人守着一棵树，各种动物会来撞树，其中80%的概率出现的是兔子，20%的概率出现的是老虎。 兔子撞树后，60%的概率兔子撞晕了，人直接捡到兔子，40%的概率兔子没撞晕，人有50%的概率抓到活兔子 老虎撞树后，30%的概率老虎撞晕了，人直接捡到老虎。70%概率老虎没撞晕。对于没撞晕的老虎，人有30%的概率打死老虎，捡到老虎。40%的概率没打死老虎，老虎跑掉。还有30%的概率人被老虎咬死了，这时游戏结束。 1.21 内置对象JavaScript中的对象分为3种：内置对象、浏览器对象、自定义对象 JavaScript 提供多个内置对象：Math&#x2F;Array&#x2F;Number&#x2F;String&#x2F;Boolean… 对象只是带有属性和方法的特殊数据类型。 学习一个内置对象的使用，只要学会其常用的成员的使用（通过查文档学习） 可以通过MDN&#x2F;W3C来查询 内置对象的方法很多，我们只需要知道内置对象提供的常用方法，使用的时候查询文档。 1.21.1 MDNMozilla 开发者网络（MDN）提供有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 MDN 通过查询MDN学习Math对象的random()方法的使用 1.21.2 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 实例对象:通过构造函数创建出来,实例化的对象 静态对象:不需要创建,直接就是一个对象,方法(静态方法)直接通过这个对象名字调用, 实例方法必须通过实例对象调用 静态方法必须通过大写的对象调用 演示：Math.PI、Math.random()、Math.floor()&#x2F;Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.pow()/Math.sqrt() // 求指数次幂/求平方根 案例 求10-20之间的随机数 随机生成颜色RGB 12345678910111213141516function getColor() &#123; var str = &quot;#&quot;; //一个十六进制的值的数组 var arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]; for (var i = 0; i &lt; 6; i++) &#123; //产生的每个随机数都是一个索引,根据索引找到数组中对应的值,拼接到一起 var num = parseInt(Math.random() * 16); str += arr[num]; &#125; return str;&#125;//页面记载的事件window.onload = function () &#123; //在文档中通过id属性的值查找这个元素(标签).设置该标签的背景颜色 document.getElementById(&quot;dv&quot;).style.backgroundColor = getColor();&#125;; 猜数字游戏 从键盘输入数字，对一个指定的随机数(随机数值在1-100之间)进行猜，如果猜错了，提示大了或小了，如果猜对了，游戏结束。 要求写一个猜数字的工具函数GusessTool,函数提供一个静态方法guess{},在该方法中实现具体功能 1.21.3 Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 &#x27;2015-5-1&#x27; new Date(&#x27;2015-5-1&#x27;)3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) 日期格式化方法 12345678toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString()toLocaleString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!date instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? &#x27;0&#x27; + month : month; date = date &lt; 10 ? &#x27;0&#x27; + date : date; hour = hour &lt; 10 ? &#x27;0&#x27; + hour : hour; minute = minute &lt; 10 ? &#x27;0&#x27; + minute:minute; second = second &lt; 10 ? &#x27;0&#x27; + second:second; return year + &#x27;-&#x27; + month + &#x27;-&#x27; + date + &#x27; &#x27; + hour + &#x27;:&#x27; + minute + &#x27;:&#x27; + second;&#125; 计算时间差，返回相差的天&#x2F;时&#x2F;分&#x2F;秒 123456789101112131415161718192021222324//作用求两个日期时间的时间间隔function getSpaceBetweenDate(date1,date2) &#123; //1.得到两个日期之间的秒数 var between = Math.round(Math.abs(date1 - date2)/1000); //2.把秒数转换成相差多少天 多少小时 多少分钟 多少秒 var day = Math.floor(between/(24*60*60)); var hour = Math.floor(between/60/60) % 24; var minute = Math.floor(between/60)%60; var second = between%60; //3.包装一个对象返回 var obj = &#123; day:day, hour:hour, minute:minute, second:second &#125; return obj;&#125;var date1 = new Date(&quot;2017-8-8 22:23:23&quot;);var date2 = new Date(&quot;2017-10-8 23:30:30&quot;);//使用自己写的方法求两个时间的差var o = getSpaceBetweenDate(date1,date2);console.log(o); 1.21.4 Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array(&#x27;zs&#x27;, &#x27;ls&#x27;, &#x27;ww&#x27;);// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()&#x2F;valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组的原始值。数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021222324// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选)every() //返回值是布尔类型。作用是判断函数中的每个元素是否满足指定要求，要求入参一个函数函数,函数中有三个参数,第一个参数是元素的值，第二个参数是索引值,第三个参数是函数的调用者filter() //返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组forEach() //遍历数组用---相当于for循环map() //数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中// 7 方法将数组的所有元素连接到一个字符串中。join() 12345678910111213141516171819202122232425262728293031var arr=[1000,2000,3000];//a----: 元素的值//b----: 索引的值//c----:谁调用了这个方法,那么c就是谁----&gt;arrvar flag= arr.every(function (a,b) &#123; //console.log(a+&quot;===&quot;+b+&quot;====&quot;+c); return a&gt;2000;//数组中的每个元素的值都要大于2000的情况,最后才返回true&#125;);var arr=[&quot;小明明lkko&quot;,&quot;小曹操674&quot;,&quot;小白白bd&quot;,&quot;笑眯眯a&quot;];var flag=arr.every(function (ele,index) &#123; //数组中的每个元素的长度是不是大于4 return ele.length&gt;4;&#125;);var newArr=arr.filter(function (ele) &#123;//ele---每个元素 return ele&gt;40;&#125;);console.log(newArr);var arr=[10,0,20,0,40,0,60,100];var newArr=arr.filter(function (ele) &#123; return ele!=0;&#125;);console.log(newArr); 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || &#x27;,&#x27;; array = array || []; if (array.length == 0)&#123; return &#x27;&#x27;; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, &#x27;-&#x27;));console.log(array.join(&#x27;-&#x27;)) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;a&#x27;];do &#123; var index = array.indexOf(&#x27;a&#x27;,index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;a&#x27;];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; returm tmpArray;&#125;console.log(clear(array)); 1.21.5 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String&#x2F;Number&#x2F;Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = &#x27;zhangsan&#x27;;var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String(&#x27;zhangsan&#x27;);var s2 = s1.substring(5);s1 = null; 12345678// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number(&#x27;18&#x27;); //类型转换,强字符串18转换为数值类型var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 1.21.6 String对象 字符串的不可变 12345var str = &#x27;abc&#x27;; //常量区 类型为stringstr = &#x27;hello&#x27;; //常量区// 当重新给str赋值的时候，常量&#x27;abc&#x27;不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String(&#x27;Hello World&#x27;); //堆区，类型为object// 获取字符串中字符的个数console.log(str.length); 字符串的内存 12345678910var s1 = &quot;11&quot;;var s2 = &quot;11&quot;;var s3 = new String(&quot;11&quot;);var s4 = new String(&quot;11&quot;);console.log(s1 == s2); //trueconsole.log(s2 == s3); //true //自动拆箱console.log(s2 === s3); //fasle //类型不一致console.log(s3 == s4); //false 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 1234567891011121314151617181920212223// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置，end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search()replace()split()fromCharCode()// String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = &quot;我爱中华人民共和国&quot;;s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 1234567891011var s = &#x27;oaooooobcoefoxyozzoppooooo&#x27;;//console.log(s.indexOf(&quot;o&quot;,7));var index = -1;while(true)&#123; index = s.indexOf(&quot;o&quot;,index+1); if(index == -1)&#123; break; &#125; console.log(index);&#125; 把字符串中所有的o替换成! 12345678var s = &#x27;abcoefoxyozzopp&#x27;;do &#123; s = s.replace(&#x27;o&#x27;, &#x27;&#x27;);&#125; while (s.indexOf(&#x27;o&#x27;) &gt; -1);console.log(s);//正则使用console.log(s.replace(/o/ig, &#x27;&#x27;)); 判断一个字符串中出现次数最多的字符，统计这个次数 12345678910111213141516171819202122var s = &#x27;abcoefoxyozzopp&#x27;;var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char); 作业12345678给定一个字符串如：“abaasdffggghhjjkkgfddsssss3444343”问题如下： 1、 字符串的长度 2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数 7、 遍历字符串，并将遍历出的字符两头添加符号“@”输出至当前的文档页面。","categories":[],"tags":[]},{"title":"","slug":"CSS3","date":"2022-03-09T09:49:27.177Z","updated":"2022-03-02T07:48:00.000Z","comments":true,"path":"2022/03/09/CSS3/","link":"","permalink":"http://example.com/2022/03/09/CSS3/","excerpt":"","text":"CSS3如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷 动画 圆角 阴影 边框图片 … CSS3现状1、 浏览器支持程度差，需要添加私有前缀(移动端) 12345a) requestFullScreenb) webkitRequestFullScreenc) mozRequestFullScreend) msRequestFullScreene) oRequestFullScreen 2、移动端支持优于PC端 3、不断改进中 4、应用相对广泛 CSS3 新增选择器结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。 12345678910111213141516171819202122232425262728293031323334353637383940414243/*第一个li元素*/li:first-child&#123; color: red;&#125;/*最后一个元素*/li:last-child&#123; color: green;&#125;/*获取第10个元素*/li:nth-child(10)&#123; color: orange;&#125;/*获取倒数第3个li元素*/li:nth-last-child(3)&#123; color: purple;&#125;/*获取所有索引为偶数的li元素*/li:nth-child(even)&#123; border: 1px solid black;&#125;/*获取小于5的li元素*/li:nth-child(-n+5)&#123; background-color: #ddd;&#125;/*获取大于5的li元素*/li:nth-child(n+5)&#123; background-color: #ddd;&#125;/*获取索引顺序为6的倍数的li元素*/li:nth-child(6n)&#123; text-decoration: underline; border: 1px solid red;&#125;/*隔3个选1个*/li:nth-child(n*3+1)&#123; background-color: #ddd;&#125;# 注意点：nth-child() 匹配的时候索引是从1开始的,nth-child(2n+2) 意思是2*n+2(n的取值范围可以是0,1,2,3,4) :first-child和:first-of-type区别1234567891011/*找到P元素，通过P找到父元素，通过父元素找子元素当中类型为P的，然再去找第几个。p:first-of-typep:last-of-typep:nth-of-type(n)p:nth-last-of-type(n)如果使用的是childp:first-child找到P元素,通过P找到父元素，通过父元素找所有的子元素，找第一个元素，匹配判断类型(如果不是无效选择器)*/ 目标伪类选择器(CSS3) :target目标伪类选择器 : 选择器可用于选取当前活动的目标元素 1234:target &#123; color: red; font-size: 30px;&#125; 1234567891011121314151617&lt;style&gt; :target &#123; border: 2px solid #D4D4D4; background-color: #e5eecc; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是标题&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;#news1&quot;&gt;跳转至内容 1&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;#news2&quot;&gt;跳转至内容 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;请点击上面的链接，:target 选择器会突出显示当前活动的 HTML 锚。&lt;/p&gt; &lt;p id=&quot;news1&quot;&gt;&lt;b&gt;内容 1...&lt;/b&gt;&lt;/p&gt; &lt;p id=&quot;news2&quot;&gt;&lt;b&gt;内容 2...&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;注释：&lt;/b&gt; Internet Explorer 8 以及更早的版本不支持 :target 选择器。&lt;/p&gt;&lt;/body&gt; 伪元素选择器（CSS3) 之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式。 伪元素的作用：将特殊的效果添加到某些选择器 E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； 1234567891011121314p::first-letter &#123; font-size: 20px; color: hotpink;&#125;/* 首行特殊样式 */p::first-line &#123; color: skyblue;&#125;p::selection &#123; /* font-size: 50px; */ color: orange;&#125; 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 12345678910div::before &#123; content:&quot;开始&quot;; color: hotpink; width:100px; height:100px; display:block; /*伪元素默认是行内元素，需要display block之后才可以设置宽高*/&#125;div::after &#123; content:&quot;结束&quot;;&#125; CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 5、伪类和伪元素的区别： 123456789101112131415161.伪类用于向某些选择器添加特殊的效果。2.伪元素用于将特殊的效果添加到某些选择器（往往是修改元素内容）。3.通俗来说，伪类的效果可以通过添加实际的类来实现,伪元素的效果可以通过添加实际的元素来实现,它们的本质区别就是是否抽象创造了新元素##.伪类案例：想要实现第一个em为红色，可以通过伪类或者手动添加一个class类实现&lt;p&gt; &lt;em class=&quot;aa&quot;&gt;This&lt;/em&gt; &lt;em&gt;is a text&lt;/em&gt;&lt;/p&gt;aa &#123; color: red;&#125;##.伪元素案例：想要实现第一个em的第一个T为红色，可以通过给T添加一个span元素实现&lt;p&gt; &lt;em&gt;&lt;span&gt;T&lt;/span&gt;his&lt;/em&gt; &lt;em&gt;is a text&lt;/em&gt;&lt;/p&gt; 伪类有： [:first-child](https://www.baidu.com/s?wd=%3Afirst-child&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao) , :link，:vistited，[:hover](https://www.baidu.com/s?wd=%3Ahover&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)，:active，:focus 伪元素有： ::first-line，::first-letter，::before，:[:after](https://www.baidu.com/s?wd=%3Aafter&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao) 注意 12341. 伪元素::before和::after添加的内容默认是inline元素；这个两个伪元素的content属性，表示伪元素的内容,设置::before和::after时必须设置其content属性，否则伪元素就不起作用。 IE6、IE7与IE8不支持此伪元素 2. CSS2中E:before或者E:after，是属于伪类的，并且没有伪元素的概念，CSS3中提出伪元素的概念E::before和E::after，并且归属到了伪元素当中，伪类里就不再存在E:before或者 E:after伪类 案例：伪元素选择器结合字体图表使用1234567891011121314151617181920212223242526272829303132333435363738/*以前字体图表使用的时候，我们往往会新增一个i或者span元素来设置字体图标，有了伪元素之后，我们可以直接使用伪元素给标签设置字体图表，节省网页中不必要的标签的使用*/&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; @font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?hrstq9&#x27;); src: url(&#x27;fonts/icomoon.eot?hrstq9#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?hrstq9&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?hrstq9&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?hrstq9#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; &#125; div &#123; width: 200px; height: 30px; border: 1px solid #ccc; margin: 100px auto; font-family: &quot;icomoon&quot;; position: relative; &#125; div::before &#123; /*是一个能插入元素的选择器*/ content: &quot;\\ea51&quot;; position: absolute; right: 10px; top: 5px; &#125; div:hover &#123; border: 1px solid red; &#125; div:hover::before &#123; color: red; &#125;&lt;/style&gt; 背景(CSS3)background-size通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下： 1234a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）b) background-size：100% 100%;---按容器比例撑满，图片变形；c) 设置为cover时，把背景图片等比例缩放到适合元素容器的尺寸，图片比例不变，但是要注意，`超出容器的部分可能会裁掉`。d) 设置为contain时，把背景图片等比例缩放到适合元素容器的尺寸（保持像素的长宽比）,`保证图片始终完整显示在背景区域`。 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .div1&#123; width: 200px; height: 200px; margin:10px auto; /*默认的背景设置，会让背景图片从左上角原点位置进行设置，不会自动的让背景图片适应容器的大小从而进行缩放*/ background: url(&quot;../images/1.jpg&quot;); &#125; .div2&#123; width: 200px; height: 200px; margin:10px auto; background: url(&quot;../images/1.jpg&quot;); /*设置背景图片的大小,指定大小，有可能会让背景图片变形*/ background-size: 200px 200px; &#125; .div3&#123; width: 200px; height: 200px; margin:10px auto; background: url(&quot;../images/1.jpg&quot;); /*设置背景图片的大小,cover:会让宽或者高适应当前容器的宽或者高，进行等比例缩放，但是超出的部分不会显示，所以有些图片的区域可能会无法显示*/ background-size: cover; &#125; .div4&#123; width: 200px; height: 200px; margin:10px auto; background: url(&quot;../images/1.jpg&quot;) no-repeat; /*设置背景图片的大小,contain:会让宽或者高适应当前容器的宽或者高，进行等比例缩放，图片完全在容器以内，但是在不重复背景图片的情况下，会造成容器的部分区域空白*/ background-size: contain; &#125;&lt;/style&gt; 12345678910111213141516## background-position使用：让背景图片居中&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 100%; height: 360px; background: url(&quot;../images/slide_01_2000x410.jpg&quot;); /*设置背景图片的大小*/ background-size: cover; /*设置position*/ background-position: center; &#125;&lt;/style&gt; background-origin121. 作用：background-origin属性规定 background-position 属性相对于什么位置来定位。默认值是left top左上角2. 语法：background-origin:padding-box|border-box|content-box; padding-box 背景图像相对于边框内边框来定位。 border-box 背景图像相对于边框盒来定位。 content-box 背景图像相对于内容框来定位。 background-clip121. background-clip 属性规定背景的绘制区：虽然是设置裁切，但是控制的是显示。说白了，就是设置最终显示那些区域2. 语法：background-clip:border-box|padding-box|content-box; 值 描述 border-box 背景被裁剪到边框盒。 显示整个区域内容 padding-box 背景被裁剪到内边距框。 显示内边框的区域 content-box 背景被裁剪到内容框。显示内容 12345678910111213141516171819202122232425262728293031&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;/*提升移动端响应区域的大小*/a&#123; width: 50px; height: 50px; display: block; background-color: #ddd; margin:100px auto; box-sizing: border-box; background-image: url(&quot;../images/sprites.png&quot;); /*添加padding*/ padding:14px; /*设置背景坐标的原点 border-box:从border的位置开始填充背景，会与border重叠 padding-box:从padding的位置(内边距)开始填充背景，会与padding重叠 content-box:从内容的位置开始填充背景*/ background-origin: content-box; /*设置内容的裁切:设置的是裁切，控制的是显示 border-box:其实是显示border及以内的内容 padding-box:其实是显示padding及以内的内容 content-box:其实是显示content及以内的内容*/ background-clip: content-box;&#125;&lt;/style&gt; background-repeat和background-attachement12345678background-repeat : 1.round:会将图片进行缩放之后再平铺 2.space:图片不会缩放平铺，只是会在图片之间产生相同的间距值background-attachment : 1.fixed:背景图片的位置固定不变 2.scroll:当滚动容器的时候，背景图片也会跟随滚动 3.local:背景图片会跟随内容一起滚动 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div&gt; &lt;p style=&quot;height: 800px;&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;span style=&quot;height: 800px;display: block&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;style&gt; div&#123; width: 500px; height: 500px; border: 1px solid red; overflow: scroll; /*1.添加背景颜色*/ /*background-color: skyblue;*/ /*2.添加背影图片 如果图片大于容器，那么默认就从容器左上角开始放置 如果图片小于容器，那么图片默认会平铺*/ /*background-image: url(&quot;../images/bg-img.jpg&quot;);*/ background-image: url(&quot;../images/share1.png&quot;); /*3.设置背景平铺 round:会将图片进行缩放之后再平铺 space:图片不会缩放平铺，只是会在图片之间产生相同的间距值*/ /*background-repeat: round;*/ /*4.设置在滚动容器的背景的行为：跟随滚动/固定 scroll ： 背景图随着内容的滚动而滚动(但是设置overflow:auto overflow:scroll无效)。设置scroll背景图是相对于元素固定。 fixed ：背景图静止。设置fixed的背景图片是相对于页面可视区域的左上角，fixed不会随着滚动条的滚动而滚动，它只会固定在页面中的某一个位置。 local：背景图片随着内容的滚动而滚动(此时没有overflow的限制)。设置local的背景图是相对于元素的内容固定。 */ background-attachment: scroll; &#125;&lt;/style&gt; 颜色设置HTML5中添加了一些新的颜色的表示方式 RGBA说得简单一点就是在RGB的基础上加进了一个通道Alpha。RGBA在RGB的基础上多了控制alpha透明度的参数。以上R、G、B三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。并非所有浏览器都支持使用百分数值。A参数，取值在0~1之间，不可为负值。RGBA比元素设置CSS的透明度更好，因为单独的颜色可以在不影响整个元素的透明度，他不会影响到元素其他的属性，比如说边框，字体同时也不会影响到其他元素的相关透明度 1234R：红色值。正整数| 百分数G：绿色值。正整数| 百分数B：蓝色值。正整数|百分数A：透明度。取值0~1之间 123456div&#123; width: 200px; height: 200px; background-color: rgba(10,20,245,0.5); color: white;&#125; HSLA(H,S,L,A)：123456789此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度语法：H：Hue(色调,色相)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 – 360,过渡为：(红橙黄绿青蓝紫红)S：Saturation(饱和度)。取值为：0.0% - 100.0%。值越大颜色越深。L：Lightness(亮度)。取值为：0.0% - 100.0%，50%是平衡值。值越小越黑，值越大越白A：Alpha透明度。取值0~1之间。# 可以通过windows的画图工具查看此种方式下的颜色设置 12345678910111213141516171819202122span&#123; width: 200px; height: 200px; display: block; background-color: hsla(360,100%,50%,0.6); color: white;&#125;# opacity的补充div&#123; width: 200px; height: 200px; background-color: blue; margin:100px auto; /*通过opacity设置透明度:如果设置父容器，那么父容器中的所有子元素也会透明*/ opacity: 0.5;&#125;span&#123; position: absolute; left: 650px; top: 100px;&#125; 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子 123text-shadow:水平位置 垂直位置 模糊距离 阴影颜色;/*text-shadow中前两项是必须写的。 后两项可以选写。*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt; &lt;div class=&quot;demo demo1&quot;&gt;中华人民共和国&lt;/div&gt; &lt;div class=&quot;demo demo2&quot;&gt;中华人民共和国&lt;/div&gt; &lt;div class=&quot;demo demo3&quot;&gt;中华人民共和国&lt;/div&gt; &lt;div class=&quot;demo demo4&quot;&gt;中华人民共和国&lt;/div&gt; &lt;div class=&quot;demo demo5&quot;&gt;中华人民共和国&lt;/div&gt; &lt;div class=&quot;demo demo6&quot;&gt;中华人民共和国&lt;/div&gt; &lt;div class=&quot;demo demo7&quot;&gt;中华人民共和国&lt;/div&gt;&lt;/body&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .demo&#123; width: 600px; padding: 30px; background-color: #666; margin:20px auto; text-align: center; font:bold 80px/100% &quot;微软雅黑&quot;; color: #fff; &#125; /*添加阴影 text-shadow:offsetX offsetY blur color*/ .demo1&#123; text-shadow: -2px -2px 5px red; &#125; .demo2&#123; text-shadow: 0px 0px 30px #fff; &#125; /*多层阴影效果*/ .demo3&#123; text-shadow: 0px 0px 30px #fff,0px 0px 50px red,0px 0px 70px #fff; &#125; .demo4&#123; color: black; text-shadow: 0px 1px 0px #fff; &#125; /*浮雕立体效果*/ .demo5&#123; color: #fff; text-shadow: -1px -1px 0px #eee,-2px -2px 0px #ddd,-3px -3px 0px #ccc; &#125; .demo6&#123; color: transparent; text-shadow: 0px 0px 8px hsla(30,100%,30%,1); &#125; &lt;/style&gt; 凹凸文字123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; div &#123; color: #ccc; font: 700 80px &quot;微软雅黑&quot;; &#125; div:first-child &#123; /* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */ text-shadow: 1px 1px 1px #000, -1px -1px 1px #fff; &#125; div:last-child &#123; /* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */ text-shadow: -1px -1px 1px #000, 1px 1px 1px #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是凸起的文字&lt;/div&gt; &lt;div&gt;我是凹下的文字&lt;/div&gt;&lt;/body&gt; 边框边框圆角border-radius可以通过值来定义样式相同的角，也对每个角分别定义 1.值的说明： 1234border-radius：*px: 将创建四个大小一样的圆角border-radius: *px *px *px *px: 四个值分别表示左上角、右上角、右下角、左下角border-radius: *px *px：第一个值表示左上角、右下角；第二个值表示右上角、左下角border-radius: *px *px *px：第一个值表示左上角；第二个值表示右上角、左下角；第三个值表示右下角 2.单个圆角的设置：除了同时设置四个圆角以外，还可以单独对每个角进行设置。对应四个角，CSS3提供四个单独的属性： 1234border-top-left-radiusborder-top-right-radiusborder-bottom-right-radiusborder-bottom-left-radius 这四个属性都可以同时设置1到2个值。如果设置1个值，表示水平半径与垂直半径相等。如果设置2个值，第一个值表示水平半径，第二个值表示垂直半径 3.补充：创建两个值的非对称圆角还有一种书写方式：如border-radius:20px/10px;表示在水平方向上20px,在垂直方向上10px;具体说明如下：可分别设置长、短半径，以“/”进行分隔 12345678910111213141516171819202122232425262728293031323334353637div&#123; width: 200px; /*height: 200px;*/ height: 100px; background-color: red; margin: 100px auto; /*添加边框圆角*/ /*1.设置一个值：四个角的圆角值都一样*/ /*border-radius: 10px;*/ /*2.设置两个值:第一个值控制左上/右下，第二个值控制右上/左下*/ /*border-radius: 10px 30px;*/ /*3.设置三个值：第一个值控制左上，第二值控制右上/左下，第三个值控制右下*/ /*border-radius: 10px 40px 60px;*/ /*4.设置四个值：左上 右上 右下 左下*/ /*border-radius: 10px 30px 60px 100px;*/ /*添加/是用来设置当前个不同方向的半径值 水平x方向/垂直y方向*/ /*border-radius: 100px/50px;*/ /*添加某个角点的圆角*/ /*border-radius: 0px 50px 0px 0px;*/ /*border-上下-左右-radius:*/ /*border-top-right-radius: 100px; border-top-left-radius: 100px;*/ /*border-bottom-left-radius: 100px; border-bottom-right-radius: 100px;*/ /*设置某个角点的两个方向上的不同圆角*/ /*border-top-right-radius: 100px 50px; border-bottom-left-radius: 80px 40px; border-bottom-right-radius: 60px 30px; border-top-left-radius: 40px 20px;*/ /*如果想设置四个角点的不同方向上的不同圆角值*/ /*分别是水平方向的：左上，右上，右下，左下 / 垂直方向的：左上，右上，右下，左下*/ border-radius: 100px 0px 0px 0px/20px 0px 0px 0px;&#125; 案例：安卓机器人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;an_header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;an_body&quot;&gt;&lt;/div&gt; &lt;div class=&quot;an_footer&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; body&#123; background-color: #ccc; &#125; .content&#123; width: 500px; height: 500px; border: 1px solid red; margin:50px auto; &#125; .an_header&#123; width: 250px; height: 125px; background-color: darkgreen; margin: 10px auto; /*添加圆角*/ border-radius: 125px 125px 0 0; position: relative; &#125; /*使用伪元素添加眼睛*/ .an_header::before, .an_header::after&#123; /*1.一定设置content属性*/ content: &quot;&quot;; /*2.如果需要设置宽度就应该转换其为块级元素，它默认是行级元素 float display position*/ position: absolute; bottom: 40px; width: 20px; height: 20px; border-radius: 10px; background-color: #fff; &#125; .an_header::before&#123; left: 70px; &#125; .an_header::after&#123; right: 70px; &#125; .an_body&#123; width: 250px; height: 250px; background-color: darkgreen; border-radius: 0px 0px 20px 20px; margin:0 auto; position: relative; &#125; .an_body::before, .an_body::after&#123; content: &quot;&quot;; position: absolute; top: 20px; background-color: darkgreen; width: 30px; height: 180px; border-radius: 10px; &#125; .an_body::before&#123; left:-40px; &#125; .an_body::after&#123; right:-40px; &#125; .an_footer&#123; width: 250px; height: 100px; position: relative; margin:0 auto; &#125; .an_footer::before, .an_footer::after&#123; content: &quot;&quot;; position: absolute; top: 00px; background-color: darkgreen; width: 30px; height: 90px; border-radius: 0px 0px 10px 10px; &#125; .an_footer::before&#123; left: 50px; &#125; .an_footer::after&#123; right: 50px; &#125;&lt;/style&gt; 边框阴影1.box-shadow 属性向边框添加一个或多个阴影。 2.语法：box-shadow: h-shadow v-shadow blur spread color inset; 3.注释：box-shadow 向框 一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。 4.属性值说明： 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。值越大，阴影的扩散面积越大 color 可选。阴影的颜色。 inset 可选。将外部阴影 (outset) 改为内部阴影。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!--文本阴影：text-shadow:offsetX offsetY blur color--&gt;&lt;!--边框阴影：box-shadow:h v blur spread color inseth:水平方向的偏移值v:垂直方向的偏移值blur:模糊--可选，默认0spread:阴影的延伸，扩展和收缩阴影的大小--可选 默认0color:颜色--可选，默认黑色inset:内阴影--可选,默认是外阴影--&gt;&lt;!--&lt;div&gt;&lt;/div&gt;--&gt;&lt;div class=&quot;items&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/pic_1.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/pic_2.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/pic_3.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/pic_4.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; img &#123; width: 100%; display: block; &#125; .items &#123; padding: 30px; overflow: hidden; &#125; .item &#123; width: 200px; height: 200px; padding-bottom: 100px; margin-right: 30px; border: 1px solid #CCC; background-color: #FFF; float: left; &#125; /*需求：为前面四个图片盒子添加右下角的外阴影，为最后个盒子添加四个方向的内阴影*/ .item:nth-of-type(-n+4)&#123; box-shadow: 3px 3px 3px #ccc; &#125; .item:last-of-type&#123; box-shadow: 3px 3px 3px #ccc inset,-3px -3px 3px #ccc inset; &#125;&lt;/style&gt; 边框图片123456789101112131415161718192021222324252627282930313233343536373839&lt;div&gt;边框图片的宽度。如果没有设置这个属性，那么宽度默认就是元素的原始的边框宽度&lt;/div&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 200px; height: 200px; margin:100px auto; box-sizing: border-box; /*增加边框不会影响盒子大小*/ border: 27px solid red; /*添加边框图片*/ /*border-image-source:可以指定边框图片的路径,默认只是填充到容器的四个角点*/ /* border-image-source: url(&quot;images/border1.png&quot;); */ /*border-image-slice:作用指定边框图像顶部、右侧、底部、左侧内偏移量，就是把边框图像切成9个区域：4个角、4边区域和一个中间部位，也就是九宫格 fill:做内容的内部填充(让第九张图是否出现)*/ /* border-image-slice: 27 fill; */ /*border-image-width:边框图片的宽度。如果没有设置这个属性，那么宽度默认就是元素的原始的边框宽度。 建议：一般将值设置为原始的边框的宽度*/ /* border-image-width: 27px; */ /*border-image-outset: 27px; 作用将背景图片延伸到盒子外，不会放大，只会延伸*/ /*border-image-repeat: stretch:拉伸 repeat:直接重复平铺 round:将内容缩放进行完整的重复平铺*/ /* border-image-repeat: round; */ /*缩写：*/ /*border-image: source slice / width/outset repeat;*/ border-image: url(&quot;images/border1.png&quot;) 27 / 27px /0px round; &#125;&lt;/style&gt;参照：http://blog.sina.com.cn/s/blog_5f2389f90102vks0.html 边框图案例1234567891011121314151617181920212223242526&lt;body&gt; &lt;div&gt;边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置边框图片的本质是背景，并不会影响元素内容的放置&lt;/div&gt;&lt;/body&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 500px; height: auto; border: 10px solid red; margin:100px auto; /*添加边框图片*/ border-image-source: url(&quot;../images/btn_bg.png&quot;); /*设置受保护的区域大小*/ border-image-slice: 10 fill; /*设置边框图片的宽度 1.明确圆角的大小 2.明确受保护的区域的大小*/ border-image-width: 10px; /*设置背景平铺效果 默认是stretch：拉伸*/ border-image-repeat: stretch; &#125;&lt;/style&gt; 渐变渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。可分为线性渐变、径向渐变 1.linear-gradient线性渐变12345678910linear-gradient(方向，开始颜色位置，颜色2位置，颜色3位置...)第一个参数表示线性渐变的方向，1. to left：设置渐变为从右到左。相当于: 270deg;2. to right：设置渐变从左到右。相当于: 90deg; 3. to top：设置渐变从下到上。相当于: 0deg;4. to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。也可以直接指定度数，如45deg第二个参数是起点颜色,可以指定颜色的位置第三个参数是终点颜色，你还可以在后面添加更多的参数，表示多种颜色的渐变 示例： 1234567div&#123; width: 400px; height: 400px; margin: 100px auto; /*多个终止色*/ background: linear-gradient(0deg,red,orange,yellow,green, #00ffff,blue,purple);&#125; 2.radial-gradient径向渐变12345678910radial-gradient(·形状 大小 坐标·,颜色1，颜色2...)：指从一个中心点开始沿着四周产生渐变效果第一个参数：1.&lt;position&gt; 确定圆心的位置。如果提供2个参数，第一个表示横坐标，第二个表示纵坐标；如果只提供一个，第二值默认为50%，即center2.shape：渐变的形状，ellipse表示椭圆形，circle表示圆形。默认为ellipse，如果元素形状为正方形的元素，则ellipse和circle显示一样3.size：渐变的大小，即渐变到哪里停止， 它有四个值。 closest-side：最近边；farthest-side：最远边； closest-corner：最近角； farthest-corner：最远角。默认是最远的角farthest-corner第二个参数：&lt;color&gt;：指定起始颜色。Rgba hsla 一些案例示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.div1&#123; width: 200px; height: 200px; margin: 10px auto; /*设置径向渐变效果:从中心点开始，从一种颜色到另外一种颜色*/ background: radial-gradient(circle at center,red,blue);&#125;.div2&#123; width: 200px; height: 200px; border-radius: 100px; margin: 10px auto; /*设置径向渐变效果:从指定坐开始，从一种颜色到另外一种颜色*/ background: radial-gradient(circle at 50px 50px,red,blue);&#125;.div3&#123; width: 200px; height: 200px; border-radius: 100px; margin: 10px auto; /*设置径向渐变效果:从指定坐标开始，从一种颜色到另外一种颜色，同时指定颜色的位置*/ background: radial-gradient(circle at 50px 50px,red 0%,blue 70%,yellow 80%,green 100%);&#125;/*指定渐变的形状*/.div4&#123; width: 200px; height: 100px; margin: 10px auto; /*设置径向渐变效果:从中心点开始，从一种颜色到另外一种颜色*/ background: radial-gradient(ellipse at center,red,green,blue);&#125;/*指定渐变的size*/.div5&#123; width: 200px; height: 100px; margin: 10px auto; /*设置径向渐变效果:从中心点开始，从一种颜色到另外一种颜色,同时指定了大小为渐变到最近的边 closest-side：最近边；farthest-side：最远边； closest-corner：最近角； farthest-corner：最远角。默认是最远的角farthest-corner */ background: radial-gradient(circle closest-side at center,red,green,blue);&#125;/*使用系统提供的位置设置*/.div6&#123; width: 200px; height: 100px; margin: 10px auto; /*设置径向渐变效果:从右上角点开始，从一种颜色到另外一种颜色*/ background: radial-gradient(circle farthest-corner at top right,red,green,blue);&#125;参考：https://www.cnblogs.com/lvmylife/p/5422064.html 3.重复渐变1234567891011121314151617181920212223242526&lt;style&gt;body&#123; background-color: #ccc;&#125;div:first-of-type&#123; width: 300px; height: 300px; /*background: radial-gradient( #fff 0%,#fff 10%, #000 10%,#000 20%, #fff 20%,#fff 30%, #000 30%,#000 40%);*/ /*重复的径向渐变*/ background: repeating-radial-gradient(circle closest-side at center center, #fff 0%,#fff 10%, #000 10%,#000 20%);&#125;div:last-of-type&#123; width: 200px; height: 800px; /*重复的线性渐变*/ background: repeating-linear-gradient(45deg, #fff 0%,#fff 10%, #000 10%,#000 20%);&#125;&lt;/style&gt; CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 1234可以分成两种情况：1、box-sizing: content-box padding会撑大盒子2、box-sizing: border-box padding不会撑大盒子3、IE8及以上版本支持该属性，Firefox 需要加上浏览器厂商前缀-moz-，对于低版本的IOS和Android浏览器也需要加上-webkit- 12345678910111213141516171819div:first-child &#123; width: 200px; height: 200px; background-color: pink; box-sizing: content-box; /* 就是以前的标准盒模型 w3c */ padding: 10px; border: 15px solid red; /* 盒子实际大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */&#125;div:last-child &#123; width: 200px; height: 200px; background-color: purple; padding: 10px; box-sizing: border-box; /* padding border 不撑开盒子 */ border: 15px solid red; /* margin: 10px; */ /* 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 */&#125; 案例：移动盒子显示边框1234567891011121314151617181920212223/*使用伪元素和box-sizing实现鼠标移动到图片上显示边框*/&lt;div&gt; &lt;img src=&quot;aa.jpg&quot;/&gt;&lt;/div&gt;&lt;style&gt;div&#123; width:532px; height:340px; position:relative;&#125;div:hover::after&#123; content:&quot;&quot;; position:absolute; width:100%; height:100%; top:0; /*让after出现的新内容和原来div盒子重叠*/ left:0; border:20px solid red; box-sizing:border-box; /*增加边框不会影响盒子大小*/&#125;&lt;/style&gt; 过渡(CSS3)[https://www.cnblogs.com/dhsz/p/6478501.html ]() 在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），允许 CSS属性值在一定的时间区间内平滑的过渡 。 123语法格式:transition: 要过渡的属性 花费时间 运动曲线 何时开始;如果有多组属性变化，还是用逗号隔开。 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 1234如果想要所有的属性都变化过渡， 写一个all 就可以transition-duration 花费时间，单位是秒s，比如 0.5s，这个s单位必须写。ms毫秒运动曲线 默认是ease何时开始 默认是0s，立马开始 运动曲线示意图： 1234567891011121314div &#123; width: 200px; height: 100px; background-color: pink; /* transition: 要过渡的属性 花费时间 运动曲线 何时开始; 这句话写到div里面而不是 hover里面 */ transition: width 0.6s ease 0s, height 0.3s ease-in 1s; /* transition: all 0.6s; 所有属性都变化用all 就可以了 后面俩个属性可以省略 */&#125;div:hover &#123; /* 鼠标经过盒子，我们的宽度变为400 */ width: 600px; height: 300px&#125; 因为transition最早是有由webkit内核浏览器提出来的，mozilla和opera都是最近版本才支持这个属性，而我们的大众型浏览器IE全家都是不支持，另外由于各大现代浏览器Firefox,Safari,Chrome,Opera都还不支持W3C的标准写法，所以在应用transition时我们有必要加上各自的前缀，最好在放上我们W3C的标准写法，这样标准的会覆盖前面的写法，只要浏览器支持我们的transition属性，那么这种效果就会自动加上去，如 1234-moz-transition: all 5s ease 1s;-webkit-transition: all 1s ease 1s;-o-transition: all 1s ease 1s;transition: all 1s ease 1s; transition案例：京东12345678910111213141516171819202122232425&lt;div&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;style&gt; a &#123; float: left; width: 183px; height: 130px; overflow: hidden; margin: 10px; &#125; img &#123; width: 193px; height: 130px; transition: margin-left 0.4s; &#125; a:hover img &#123; margin-left: -10px; &#125;&lt;/style&gt; transition案例：显示阴影123456789101112&lt;style&gt; div &#123; width: 150px; height: 300px; border: 1px solid #ccc; transition: all 0.6s; &#125; div:hover &#123; box-shadow: 0 10px 20px rgba(0,0,0,0.5); transform: translateY(-20px); &#125;&lt;/style&gt; transition案例：手风琴效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .menu&#123; width: 200px; height:auto; margin:100px auto; &#125; .item&#123; width: 100%; height:auto; &#125; .item &gt; h3&#123; height: 40px; line-height: 40px; background-color: #7dffe7; color: orange; border-bottom: 2px solid #ccc; padding-left:10px; &#125; .item &gt; .itemBox&#123; width: 100%; height:0px; overflow: hidden; /*display: none;*/ /*添加过渡效果:过渡效果只能产生从某个值到另外一个具体的值的过渡*/ /*1.一定要设置为哪些css样式添加过渡效果*/ /*transition-property: display;*/ transition-property: height; /*2.一定要设置过渡效果的耗时*/ transition-duration: 1s; &#125; .item &gt; .itemBox &gt; ul&#123; list-style: none; background-color: #eaffb6; padding:10px; &#125; /*为item添加hover伪类*/ .item:hover &gt; .itemBox&#123; /*display: block;*/ height: 110px; &#125;&lt;/style&gt;&lt;div class=&quot;menu&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;h3&gt;市内新闻&lt;/h3&gt; &lt;div class=&quot;itemBox&quot;&gt; &lt;ul&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h3&gt;省内新闻&lt;/h3&gt; &lt;div class=&quot;itemBox&quot;&gt; &lt;ul&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h3&gt;国内新闻&lt;/h3&gt; &lt;div class=&quot;itemBox&quot;&gt; &lt;ul&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;h3&gt;国际新闻&lt;/h3&gt; &lt;div class=&quot;itemBox&quot;&gt; &lt;ul&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;li&gt;深圳超市肉菜档遭抢&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2D变形(CSS3) transformtransform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 transform允许元素出现形变。 移动 translate(x, y) 123//translate 移动平移的意思translate(50px,50px);//使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。 1234//可以改变元素的位置，x、y可为负值；translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）translateX(x)仅水平方向移动（X轴移动）translateY(Y)仅垂直方向移动（Y轴移动） 12345678div:hover&#123; /*设置两个值，第一个参数表示X方向 第二个参数表示Y方向*/ /*transform: translate(100px,100px);*/ /*也可以只传入一个参数，表示X方向*/ /*transform: translate(100px);*/ /*也可以指定具体的方向,如下代码，表示Y方向正值方向上移动100px*/ transform:translateY(100px);&#125; 缩放 scale(x, y) 12transform:scale(0.8,1);//可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。 12345scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）scaleX(x)元素仅水平方向缩放（X轴缩放）scaleY(y)元素仅垂直方向缩放（Y轴缩放）// scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大 12345678div:hover&#123; /*传入两个值，第一个参数表示X方向的缩放 第二个参数表示Y方向上的缩放*/ /*transform: scale(2,0.5);*/ /*也可以只传入一个值，表示X方向和Y方向上相同的缩放*/ /*transform: scale(2);*/ /*也可以指定具体方向上的缩放*/ transform: scaleX(2);&#125; 旋转 rotate(deg) 123//可以对元素进行旋转，正值为顺时针，负值为逆时针；transform:rotate(45deg);//注意单位是 deg 度数 123456div:hover&#123; /*传入旋转的角度，如果正值，则进行顺时针旋转*/ /*transform: rotate(90deg);*/ /*如果传入负值，则逆时针旋转*/ transform: rotate(-270deg);&#125; transform-origin可以调整元素转换变形的原点 1234div&#123; transform-origin: left top; transform: rotate(45deg); &#125; /* 改变元素原点到左上角，然后进行顺时旋转45度 */ 如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用 px 像素。 1234div&#123; transform-origin: 10px 10px; transform: rotate(45deg); &#125; /* 改变元素原点到x 为10 y 为10，然后进行顺时旋转45度 */ 倾斜 skew(deg, deg) 1transform:skew(30deg,0deg); 该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。倾斜之后还会保留原来元素的高度，所以当倾斜的角度为90度时会出问题。 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。 1234div:hover&#123; /*在X方向上倾斜30度*/ transform: skewX(30deg);&#125; 2D变形案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt;&lt;/body&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 100px; height: 100px; background-color: red; margin-left: 200px; margin-top:10px; /*添加过渡效果 css样式名称 耗时*/ transition: transform 2s; &#125; /*移动translate*/ div:first-of-type:active&#123; /*使用transform实现元素的移动 a.移动是参照元素的左上角 b.执行完毕之后会恢复到原始状态 1.如果只有一个参数就代表x方向 2.如果有两个参数就代表x/y方向*/ /*transform: translate(100px);*/ /*transform: translate(400px,500px);*/ /*transform: translate(0px,500px);*/ /*添加水平或者垂直方向的移动*/ /*transform:translateX(300px);*/ transform:translateY(300px); &#125; /*缩放：scale*/ div:nth-of-type(2):active&#123; /*实现缩放 1指不缩放，&gt;1.01放大 &lt;0.99缩小 参照元素的几何中心 1.如果只有一个参数，就代表x和y方向都进行相等比例的缩放 2.如果有两个参数，就代表x/y方向*/ /*transform: scale(2);*/ /*transform: scale(2,1);*/ /*缩放指定的方向 */ /*transform:scaleX(0.5);*/ transform:scaleY(0.5); &#125; /*旋转：rotate*/ div:nth-of-type(3)&#123; /*设置旋转轴心 1.x y 2.关键字：left top right bottom center*/ background-color: purple; transform-origin: left top; &#125; div:nth-of-type(3):active&#123; /*transform:rotate(-90deg); transform: translateX(700px);*/ /*同时添加多个transform属性值*/ &#125; /*斜切：skew*/ div:nth-of-type(4):active&#123; background-color: blue; /*如果角度为正，则往当前轴的负方向斜切，如果角度为，则往当前轴的正方向斜切*/ transform:skew(-30deg); /*transform:skew(30deg,-30deg);*/ /*设置某个方向的斜切值*/ /*transform:skewX(30deg);*/ /*transform:skewY(30deg);*/ &#125;&lt;/style&gt; transform坐标系的变化123456789div:nth-of-type(3):active&#123; /*transform:rotate(-90deg); transform: translateX(700px);*/ /*同时添加多个transform属性值*/ transform: translateX(700px) rotate(-90deg); /*transform: rotate(-90deg) translateX(700px);*/&#125;执行上面动画的时候，会发现两个transform有两个动画效果，原因是CSS3 transform 变换使用的是元素自身坐标系，在元素旋转之后元素自身的坐标系也发生了变化变化。 纸牌旋转案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;div class=&quot;pkBox&quot;&gt; &lt;img src=&quot;../images/pk1.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/pk2.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/pk1.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/pk2.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/pk1.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/pk2.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .pkBox&#123; width: 155px; height: 219px; position: relative; margin:300px auto; &#125; .pkBox &gt; img&#123; width: 100%; height: 100%; position: absolute; left: 0; top: 0; /*添加过渡*/ transition: transform 2s; /*设置旋转轴心*/ transform-origin: right top; &#125; /*添加鼠标上移的效果*/ .pkBox:hover &gt;img:nth-of-type(1)&#123; transform: rotate(60deg); &#125; .pkBox:hover &gt;img:nth-of-type(2)&#123; transform: rotate(120deg); &#125; .pkBox:hover &gt;img:nth-of-type(3)&#123; transform: rotate(180deg); &#125; .pkBox:hover &gt;img:nth-of-type(4)&#123; transform: rotate(240deg); &#125; .pkBox:hover &gt;img:nth-of-type(5)&#123; transform: rotate(300deg); &#125; .pkBox:hover &gt;img:nth-of-type(6)&#123; transform: rotate(360deg); &#125;&lt;/style&gt; 添加多个transoform属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;../images/shield_1_01.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_02.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_03.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_04.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_05.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_06.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_07.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_08.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_1_09.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; body&#123; background-color: #31965b; &#125; .box&#123; width: 440px; margin:100px auto; &#125; .box &gt; img&#123; transition: transform 1s; &#125; .box &gt; img:nth-of-type(1)&#123; transform: translate(100px,100px) rotate(30deg); &#125; .box &gt; img:nth-of-type(2)&#123; transform: translate(-100px,-100px) rotate(-30deg); &#125; .box &gt; img:nth-of-type(3)&#123; transform: translate(200px,200px) rotate(60deg); &#125; .box &gt; img:nth-of-type(4)&#123; transform: translate(-200px,-200px) rotate(-60deg); &#125; .box &gt; img:nth-of-type(5)&#123; transform: translate(150px,150px) rotate(90deg); &#125; .box &gt; img:nth-of-type(6)&#123; transform: translate(50px,150px) rotate(-90deg); &#125; .box &gt; img:nth-of-type(7)&#123; transform: translate(-150px,-150px) rotate(60deg); &#125; .box &gt; img:nth-of-type(8)&#123; transform: translate(10px,-250px) rotate(-90deg); &#125; .box &gt; img:nth-of-type(9)&#123; transform: translate(-250px,10px) rotate(45deg); &#125; .box:hover &gt; img&#123; transform: none; &#125;&lt;/style&gt; 使用transfom实现盒子居中123456789101112131415161718192021222324252627282930&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;rec&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 400px; height: 400px; border-radius: 200px; background-color: #ccc; margin:100px auto; position: relative; &#125; .rec&#123; width: 200px; height: 200px; background-color: red; position: absolute; /*定位的百分比是参照父容器的宽高*/ left: 50%; top: 50%; /*使用transform实现元素的居中 百分比是参照元素本身的宽高*/ transform: translate(-50%,-50%); /*transform: translate(-50px,-50px);*/ &#125;&lt;/style&gt; 3D变形(CSS3) transform123452d x y 3d x y z//左手坐标系伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图 CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图 1234//简单记住他们的坐标：x 左边是负的，右边是正的y 上面是负的， 下面是正的z 里面是负的， 外面是正的 rotateX() 就是沿着 x 立体旋转. 123456img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateY()沿着y轴进行旋转 123456img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateZ()沿着z轴进行旋转 123456img &#123; transition:all .25s ease-in 0s;&#125;img:hover &#123; transform:rotateZ(180deg); &#125; rotate3d(x,y,z,angle)123456789div:hover&#123; /*Y轴方向旋转45度*/ /*transform: rotateY(45deg);*/ /*X轴方向旋转90度*/ /*transform: rotateX(90deg);*/ /*x轴和Y轴方向同时进行旋转放*/ transform: rotate3d(1,1,0,45deg);&#125; translateX(x)仅水平方向移动（X轴移动） 主要目的实现移动效果 translateY(y)仅垂直方向移动（Y轴移动） translateZ(z)transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。 比如设置了perspective(视景)为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。 translate3d(x,y,z)x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值 12345678div:hover&#123; /*Y轴移动+100px*/ /*transform:translateY(100px);*/ /*X轴移动100px*/ /*transform:translateX(100px);*/ /*x轴和Y轴方向同时移动*/ transform:translate3d(100px,100px,0px);&#125; scale3d(x,y,z)scale3d(number,number,number)使元素在这三个纬度中缩放，也可分开写，如：scaleX(),scaleY(),scaleZ() 12345678div:hover&#123; /*Y轴方向放大1倍*/ /*transform: scaleX(2);*/ /*X轴方向缩小0.5*/ /*transform: scaleX(0.5);*/ /*x轴和Y轴方向同时进行缩放*/ transform: scale3d(2,0.5,1);&#125; 案例：开门1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;section&gt; &lt;div class=&quot;door-l&quot;&gt;&lt;/div&gt; &lt;div class=&quot;door-r&quot;&gt;&lt;/div&gt;&lt;/section&gt;&lt;style&gt; section &#123; width: 450px; height: 300px; border: 1px solid #000; margin: 100px auto; background: url(images/3.jpg) no-repeat; position: relative; /*给父盒子添加透视效果:perspective属性必须应用到transformZ变换的元素的父元素上*/ perspective: 1000px; &#125; .door-l, .door-r &#123; position: absolute; top: 0; width: 50%; height: 100%; background-color: pink; transition: all 1s; /*两个门都做过渡效果*/ background: url(images/bg.png); &#125; .door-l &#123; left: 0; border-right: 1px solid #000; transform-origin: left;/* 左侧盒子按照左边翻转*/ &#125; .door-r &#123; right: 0; border-left: 1px solid #000; transform-origin: right;/* 右侧盒子按照右边翻转*/ &#125; .door-l::before, .door-r::before &#123; /*伪元素 就是插入一个元素标签*/ content: &#x27;&#x27;; position: absolute; top: 50%; width: 20px; height: 20px; border: 1px solid #000; border-radius: 50%; /*圆角*/ transform：translateY(-50%); /*translate 如果是百分比， 就是走自己高度的一半*/ &#125; .door-l::before &#123; right: 5px; &#125; .door-r::before &#123; left: 5px; &#125; /*鼠标经过section 盒子 两个门盒子 翻转 rotateY*/ section:hover .door-l &#123; transform: rotateY(-130deg); /*因为往左边翻转，所以是负值*/ &#125; section:hover .door-r &#123; transform: rotateY(130deg); &#125;&lt;/style&gt; 案例：翻转图片1234567891011121314151617181920212223242526&lt;div&gt; &lt;img src=&quot;images/qian.svg&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;images/hou.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;style&gt; div &#123; width: 224px; height: 224px; margin: 100px auto; position: relative; &#125; div img &#123; position: absolute; top: 0; left: 0; transition: all 1s; &#125; div img:first-child &#123; z-index: 1; backface-visibility: hidden; /*不是正面对向屏幕，就隐藏*/ &#125; div:hover img &#123; transform: rotateY(180deg); &#125;&lt;/style&gt; 认识preserve-3d12345678910111213141516171819202122&lt;div&gt; &lt;img src=&quot;images/pk1.png&quot; width=&quot;100&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;style&gt; body &#123; /*perspective: 1000px;*/ &#125; div &#123; width: 100px; height: 145px; border: 5px solid red; margin: 100px auto; transform: rotate3d(1,1,0,45deg); /*transform: rotateY(30deg);*/ transform-style: preserve-3d; /* preserve-3d:表示所有子元素在3D空间中呈现 */ &#125; div img &#123; transform: rotateY(30deg); border: 5px solid blue; &#125;&lt;/style&gt; 动画案例：立方体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;front&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;back&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;bottom&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 200px; height: 200px; margin:100px auto; position: relative; /*让box默认旋转，方便观察*/ transform: rotate3d(1,1,0,0deg); /*让子元素保留3d变换之后的效果*/ transform-style: preserve-3d; /*添加透视景深效果 0就是不设置透视景深效果*/ perspective: 500px; /*如果加上景深效果，因为font和back的z轴上分别向前和后移动了，所以会看到font面要大于back面*/ /*设置透视的观察角度，从不同角度上可以看到立方体不同的显示效果*/ perspective-origin: 0px 0px; &#125; .box &gt; div&#123; width: 200px; height: 200px; position: absolute; opacity: 0.5; &#125; .front&#123; background-color: red; transform: translateZ(100px); &#125; /*rotatex、rotatez的旋转正方向是顺时针，rotatey的旋转正方向是逆时针。*/ .back&#123; background-color: green; transform: translateZ(-100px) rotateY(180deg); &#125; .left&#123; background-color: blue; /*移动+旋转*/ transform: translateX(-100px) rotateY(-90deg); &#125; .right&#123; background-color: pink; transform: translateX(100px) rotateY(90deg); &#125; .top&#123; background-color: purple; transform: translateY(-100px) rotateX(90deg); &#125; .bottom&#123; background-color: orange; transform: translateY(100px) rotateX(-90deg); &#125;&lt;/style&gt;# https://blog.csdn.net/a409051987/article/details/70195417 案例：旋转轮播图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;section&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/section&gt;&lt;style&gt; body &#123; perspective: 1000px; &#125; section &#123; width: 300px; height: 200px; margin: 100px auto; background: url(images/img-1.jpg) no-repeat; background-size: cover; position: relative; transform-style: preserve-3d; /* 让父盒子里面的子盒子以3d效果显示 */ transition: 5s linear; /* 匀速 all 是可以省略的， 省略默认的all*/ &#125; section:hover &#123; transform: rotateY(360deg); &#125; section div &#123; width: 100%; height: 100%; background: url(images/dog.gif) no-repeat; background-size: cover; position: absolute; top: 0; left: 0; &#125; section div:nth-child(1) &#123; transform: rotateY(0deg) translateZ(400px); &#125; /*这边因为z轴平移了400px，当沿着Y轴旋转60°的时候，实际上是以原坐标原点旋转60°，所以下面图片会错开显示*/ section div:nth-child(2) &#123; transform: rotateY(60deg) translateZ(400px); &#125; section div:nth-child(3) &#123; transform: rotateY(120deg) translateZ(400px); &#125; section div:nth-child(4) &#123; transform: rotateY(180deg) translateZ(400px); &#125; section div:nth-child(5) &#123; transform: rotateY(240deg) translateZ(400px); &#125; section div:nth-child(6) &#123; transform: rotateY(300deg) translateZ(400px); &#125;&lt;/style&gt; 动画(CSS3) animation动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果. 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片 必要元素：关键帧 a、通过@keyframes指定动画序列；自动补间动画，确定两个点，系统会自动计算中间过程。这两个点就称为关键帧。我们可以设置多个关键帧 b、通过百分比将动画序列分割成多个节点； c、在各节点中分别定义各属性 d、通过animation将动画应用于相应元素； animation样式常用属性： 1234567891011a)动画序列的名称:animation-name: move;b)动画的持续时间:animation-duration: 1s;c)动画的延时:animation-delay: 1s;d)播放状态:animation-play-state: paused|running;e)播放速度:animation-timing-function:linear;f)播放次数 反复:animation-iteration-count: 1;g)动画播放完结后的状态:animation-fill-mode: forwards/backwards;h)循环播放时，交叉动画:animation-direction: alternate;//animation-iteration-count:infinite; 无限循环播放//animation-play-state:paused; 暂停动画 1234@keyframes 动画名称 &#123; from&#123; 开始位置 &#125; 0% to&#123; 结束 &#125; 100%&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 300px; height: 300px; margin:100px auto; &#125; div &gt; img&#123; width:100%; &#125; /*添加动画 ： 关键帧动画*/ @keyframes rotateAni &#123; 0%&#123; /*可以同时对多个属性添加动画效果*/ transform: rotate(0deg) scale(1); &#125; 50%&#123; transform: rotate(180deg) scale(2); &#125; 100%&#123; transform: rotate(360deg) scale(1); &#125; &#125; div:hover &gt; img&#123; /*动画名称-自定义*/ animation-name: rotateAni; /*动画时间*/ animation-duration: 1s; /*动画速率曲线： linear：匀速 ease：动画以低速开始，然后加快，在结束前变慢 ease-in：动画以低速开始 ease-out：动画以低速结束 ease-in-out：动画以低速开始和结束*/ animation-timing-function: linear; /*动画播放次数*/ animation-iteration-count: 4; /*动画时间延迟*/ animation-delay: 0s; /*动画播放完的状态： forwards:保持动画播放完毕后的状态 backwards:退回到原始状态(默认值)*/ animation-fill-mode: forwards; /*动画是否轮流反射播放： alternate:在规定的次数内轮流反射播放 normal:正常播放*/ /*animation-direction: alternate;*/ &#125; /*鼠标按下的时候当前div就被激活了*/ div:active &gt;img&#123; /*动画的当前播放状态： paused：暂停 running:运行*/ animation-play-state: paused; &#125;&lt;/style&gt; 动画实现无缝滚动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;../images/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../images/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 882px; height: 86px; margin:100px auto; background-color: #ddd; overflow: hidden; &#125; div &gt;ul&#123; width: 200%; list-style: none; /*1.设置的名称*/ animation-name: move; /*2.设置动画的耗时*/ animation-duration: 7s; /*3.设置无限循环*/ animation-iteration-count: infinite; /*4.设置时间函数*/ animation-timing-function: linear; &#125; div &gt; ul &gt; li&#123; width:126px; float: left; &#125; div &gt; ul &gt; li &gt; img&#123; width:100%; &#125; /*鼠标上移，停止动画*/ div:hover &gt; ul&#123; cursor: pointer; animation-play-state: paused; &#125; /*创建动画*/ @keyframes move &#123; from&#123; transform:translateX(0); &#125; to&#123; transform:translateX(-882px); &#125; &#125;&lt;/style&gt; 动画案例：钟表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;line line1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line line2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line line3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line line4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line line5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line line6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hour&quot;&gt;&lt;/div&gt; &lt;div class=&quot;minute&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .clock&#123; width: 300px; height: 300px; border: 10px solid #ccc; /*border-radius: 160px;*/ /*百分比参照元素的实际宽高*/ border-radius: 50%; margin:100px auto; position: relative; &#125; /*刻度*/ .line&#123; width: 8px; height: 300px; background-color: #ccc; position: absolute; /*参照父容器的宽*/ left: 50%; top:0; /*参照元素本身*/ transform: translate(-50%,0); &#125; .line1,.line4&#123; width: 10px; &#125; .line2&#123; transform: translate(-50%,0) rotate(30deg); &#125; .line3&#123; transform: translate(-50%,0) rotate(60deg); &#125; .line4&#123; transform: translate(-50%,0) rotate(90deg); &#125; .line5&#123; transform: translate(-50%,0) rotate(120deg); &#125; .line6&#123; transform: translate(-50%,0) rotate(150deg); &#125; /*遮盖*/ .cover&#123; width: 250px; height: 250px; border-radius: 50%; background-color: #fff; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); &#125; .hour&#123; width: 6px; height: 80px; background-color: red; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-100%); transform-origin: center bottom; /*时针是在43200秒内完成360度的旋转*/ animation: clockAnimation 43200s linear infinite; &#125; .minute&#123; width: 4px; height: 90px; background-color: green; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-100%); transform-origin: center bottom; /*分针是在3600秒内完成360度的旋转*/ animation: clockAnimation 3600s linear infinite; &#125; .second&#123; width: 2px; height: 100px; background-color: blue; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-100%); /*设置旋转轴心*/ transform-origin: center bottom; /*添加动画 steps(60) : 实现帧动画(一帧一帧的变化，而不是之前的线性liner变化) */ animation: clockAnimation 60s infinite steps(60); &#125; .center&#123; width: 20px; height: 20px; background-color: #ccc; border-radius: 50%; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); &#125; /*创建动画*/ @keyframes clockAnimation &#123; from&#123; transform:translate(-50%,-100%) rotate(0deg); &#125; to&#123; transform:translate(-50%,-100%) rotate(360deg); &#125; &#125;&lt;/style&gt; 更多动画案例，参见：https://codepen.io/ 案例：切割轮播图(立方体) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;div class=&quot;view&quot;&gt; &lt;ul&gt; &lt;!--每一个li就是一个结构块--&gt; &lt;li&gt; &lt;!--每一个span是这个结构块中的某一个面，用来显示图片--&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;pre&quot;&gt;&amp;lt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;next&quot;&gt;&amp;gt;&lt;/a&gt;&lt;/div&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;.view&#123; width: 560px; /*图片宽高为560*300*/ height: 300px; margin:100px auto; position: relative;&#125;ul&#123; width: 100%; height: 100%; list-style: none; /*这边给父亲ul添加3d效果，为的是更好的通过rotate3d观察ul元素整体的3d效果 如果将transform: rotate3d(1,1,0,-30deg)效果加到每一个li上，会因为每个li变化自己的3d造成一种视差效果 */ /*transform: rotate3d(1,1,0,-30deg);*/ transform-style: preserve-3d;&#125;ul &gt; li&#123; width: 25%; /*每个li宽度是25%*/ height: 100%; float: left;/*li左浮动，让li之间能够无缝连接在一起*/ position: relative; transform-style: preserve-3d;/*子元素span要保留3d效果，父元素li得设置preserve-3d*/ /*添加过渡动画效果*/ transition: transform 0.5s;&#125;ul &gt; li &gt; span&#123; width: 100%; height: 100%; position: absolute; /*给span定位，现在所有的span会重叠在一起，我们可以通过绝对定位+transform移动span形成立方体效果*/ left: 0; top: 0;&#125;/*给ul的所有li下的第一个span设置图片，所有ul下的第一个span会组成一张完整的图片*/ul &gt; li &gt; span:nth-of-type(1) &#123; background: url(&quot;../images/q1.jpg&quot;); /*往z轴正方向偏移*/ transform: translateZ(150px);&#125;ul &gt; li &gt; span:nth-of-type(2)&#123; background: url(&quot;../images/q2.jpg&quot;); transform: translateY(-150px) rotateX(90deg);&#125;ul &gt; li &gt; span:nth-of-type(3)&#123; background: url(&quot;../images/q3.jpg&quot;); transform: translateZ(-150px) rotateX(180deg);&#125;ul &gt; li &gt; span:nth-of-type(4)&#123; background: url(&quot;../images/q4.jpg&quot;); transform: translateY(150px) rotateX(-90deg);&#125;/*设置每一个li元素的span所显示的图片的位置*/ul &gt; li:nth-of-type(2) &gt; span &#123; background-position: -100% 0;&#125;ul &gt; li:nth-of-type(3) &gt; span &#123; background-position: -200% 0;&#125;ul &gt; li:nth-of-type(4) &gt; span &#123; background-position: -300% 0;&#125;ul &gt; li:nth-of-type(5) &gt; span &#123; background-position: -400% 0;&#125;.pre,.next&#123; width: 60px; height: 60px; text-align: center; line-height:60px; position: absolute; top: 50%; text-decoration: none; font-size: 40px; transform: translate(0,-50%); background-color: rgba(0,0,0,0.5); color: #fff;&#125;.pre&#123; left: 0;&#125;.next&#123; right: 0;&#125;&lt;/style&gt;&lt;script&gt; $(function()&#123; /*定义图片索引*/ var index=0; /*添加节流阀 true说明本次单击会有响应处理*/ var flag=true; /*下一张*/ $(&quot;.next&quot;).on(&quot;click&quot;,function()&#123; if(flag==true)&#123; /*设置节流阀*/ flag=false; index--; /*所谓下一张，就是将所有li元素围绕x旋转*/ $(&quot;li&quot;).each(function(key,value)&#123; //0 1 2 3 4 /*通过添加transform样式进行旋转*/ $(this).css(&#123; &quot;transform&quot;:&quot;rotateX(&quot;+(index*90)+&quot;deg)&quot;, &quot;transition-delay&quot;:(key*0.2)+&quot;s&quot; &#125;); &#125;); setTimeout(function()&#123; flag=true; &#125;,1000); &#125; &#125;); /*上一张*/ $(&quot;.pre&quot;).on(&quot;click&quot;,function()&#123; if(flag==true)&#123; /*设置节流阀*/ flag=false; index++; /*所谓下一张，就是将所有li元素围绕x旋转*/ $(&quot;li&quot;).each(function(key,value)&#123; //0 1 2 3 4 /*通过添加transform样式进行旋转*/ $(this).css(&#123; /*所有li旋转90度*/ &quot;transform&quot;:&quot;rotateX(&quot;+(index*90)+&quot;deg)&quot;, &quot;transition-delay&quot;:(key*0.2)+&quot;s&quot; &#125;); &#125;); setTimeout(function()&#123; flag=true; &#125;,1000); &#125; &#125;); &#125;);&lt;/script&gt; 伸缩布局(CSS3)布局的传统解决方案，基于[盒状模型](https://developer.mozilla.org/en-US/docs/Web/CSS/box_model)，依赖 [display](https://developer.mozilla.org/en-US/docs/Web/CSS/display)属性 + [position](https://developer.mozilla.org/en-US/docs/Web/CSS/position)属性 + [float](https://developer.mozilla.org/en-US/docs/Web/CSS/float)属性。它对于那些特殊布局非常不方便。 CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强,可根据剩余的宽高，灵活布局，其强大的伸缩性，在响应式开中可以发挥极大的作用。 传统布局和伸缩布局比较12345678910111213141516171819一般情况下，当我们对一部分内容进行布局的时候，会使用盒模型。常见的布局手段即是结合padding与margin设置元素的display、float和position。但是这三种方法在设置元素位置的时候，有时会相对死板并且使css语句过多。比如：A是父容器，其中有B和C两个子元素，我们要设置B和C在同一行，并且B行内左对齐，C行内右对齐，且B和C宽度一致，我们可以使用flex实现如下：A:&#123; display: flex; flex-direction: row; &#125;B:&#123; background: red; flex-grow: 1; &#125;C:&#123; background: yellow; flex-grow: 1; &#125; 伸缩盒子介绍主轴和侧轴12341.主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向2.侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的3.方向：默认主轴从左向右，侧轴默认从上到下4.主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多 各属性详解1.display:flex:如果一个容器设置了这个属性，那么这个盒子里面的所有直接子元素都会自动的变成flex item 2.flex-direction调整主轴方向（默认为水平方向） 12345678910flex-direction: column 垂直排列flex-direction: row 水平排列/*flex-direction：设置子元素的排列方向：就是用来主轴方向，默认主轴方向是row(水平方向) row:水平排列方向，从左到右 row-reverse:水平排列方向，从右到左 column:垂直排列方向，从上到下 column-reverse：垂直排列方向，从下到上*/ 携程网手机端地址 :http://m.ctrip.com/html5/ 3、justify-content调整主轴对齐（水平对齐） 子盒子如何在父盒子里面水平对齐方式 值 描述 白话文 flex-start 默认值。项目位于容器的开头。 让子元素从父容器的开头开始排序但是盒子顺序不变 flex-end 项目位于容器的结尾。 让子元素从父容器的后面开始排序但是盒子顺序不变 center 项目位于容器的中心。 让子元素在父容器中间显示 space-between 项目位于各行之间留有空白的容器内。 左右的盒子贴近父盒子，中间的平均分布空白间距 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 相当于给每个盒子添加了左右margin外边距 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;first&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;third&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;fourth&quot;&gt;4&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 1000px; height: 200px; border: 1px solid red; box-sizing: border-box; /*设置父容器为伸缩盒子：会使每一个子元素自动变成伸缩项*/ display: flex; /*设置子元素的排列方式 flex-start:让子元素从父容器的起始位置开始排列 flex-end:让子元素从父容器的结束位置开始排列 center:让子元素从父容器的中间位置开始排列 space-between:左右对齐父容器的开始和结束，中间平均分页，产生相同的间距 space-around:将多余的空间平均的分页在每一个子元素的两边 margin:0 auto.造成中间盒子的间距是左右两边盒子间距的两倍*/ justify-content: space-around; &#125; .first&#123; width: 200px; height: 100%; background-color: red; &#125; .second&#123; width: 200px; height: 100%; background-color: green; &#125; .third&#123; width: 200px; height: 100%; background-color: blue; &#125; .fourth&#123; width: 200px; height: 100%; background-color: pink; &#125;&lt;/style&gt; 4、flex-wrap控制是否换行 当我们子盒子内容宽度多于父盒子的时候如何处理 值 描述 nowrap 默认值。规定灵活的项目不拆行或不拆列。 不换行，则 收缩（压缩） 显示 强制一行内显示 wrap 规定灵活的项目在必要的时候拆行或拆列。 wrap-reverse 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。 5、flex-flow是flex-direction、flex-wrap的简写形式 12345678flex-flow: flex-direction flex-wrap; 列如：display: flex;/* flex-direction: row;flex-wrap: wrap; 这两句话等价于下面的这句话*/flex-flow: row wrap; /* 两者的综合 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;first&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;third&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;fourth&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;fifth&quot;&gt;5&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 900px; height: 600px; border: 1px solid red; box-sizing: border-box; margin:0 auto; /*设置父容器为盒子：会使每一个子元素自动变成伸缩项 当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/ display: flex; /*设置子元素的主轴方向上的排列方式*/ justify-content: space-around; /*flex-flow:是flex-wrap和flex-direction的综合 flex-wrap:控制子元素是否换行显示，默认不换行 nowrap:不换行--则收缩 wrap:换行 wrap-reverse:翻转，原来是从上到下，翻转后就是从下到上来排列*/ flex-flow: row wrap; &#125; .first&#123; width: 200px; height: 200px; background-color: red; &#125; .second&#123; width: 200px; height: 200px; background-color: green; &#125; .third&#123; width: 200px; height: 200px; background-color: blue; &#125; .fourth&#123; width: 200px; height: 200px; background-color: pink; &#125; .fifth&#123; width: 200px; height: 200px; background-color: purple; &#125;&lt;/style&gt; 6、flex-grow：扩展 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;first&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;third&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 900px; height: 600px; border: 1px solid red; margin:0 auto; /*设置父容器为盒子：会使每一个子元素自动变成伸缩项 当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/ display: flex; /*设置子元素的主轴方向上的排列方式*/ justify-content: space-around; &#125; .first&#123; width: 200px; height: 200px; background-color: red; /*flow-grow:可以来扩展子元素的宽度：设置当前元素应该占据剩余空间的比例值 比例值计算 ：当前空间的flex-grow/所有兄弟元素的flex-grow的和 flex-grow的默认是0:说明子元素并不会去占据剩余的空间*/ flex-grow: 1; &#125; .second&#123; width: 200px; height: 200px; background-color: green; flex-grow: 1; &#125; .third&#123; width: 200px; height: 200px; background-color: blue; flex-grow: 2; &#125;&lt;/style&gt; 7、flex-shrink：收缩 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;first&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;third&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 500px; height: 600px; border: 1px solid red; margin:0 auto; /*设置父容器为盒子：会使每一个子元素自动变成伸缩项 当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/ display: flex; /*设置子元素的主轴方向上的排列方式*/ justify-content: space-around; &#125; .first &#123; width: 200px; height: 200px; background-color: red; /*flex-shrink:定义收缩比例，通过设置的值来计算收缩空间 比例值计算 ：当前空间的flex-shrink/所有兄弟元素的flex-shrink的和 默认值为1*/ flex-shrink: 2; &#125; .second&#123; width: 200px; height: 200px; background-color: green; flex-shrink: 1; &#125; .third&#123; width: 200px; height: 200px; background-color: blue; flex-shrink: 1; &#125;&lt;/style&gt; 8、flex属性 123456789101112131415flex 是 flex-grow、flex-shrink、flex-basis的缩写。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto).item &#123;flex: 2;&#125;/*等效于*/.item &#123; flex-grow: 2; flex-shrink: 1; flex-basis: 0%; &#125;flex-basis属性作用：用于设置子元素的宽度，如果写了这个属性会替换掉width属性值。flex-basis:0/0%; 设置子元素的宽度为0px(不占用宽度，此时flex-grow会生效)flex-basis:auto; 在确定子元素宽度的时候首先会去参考子元素的width属性值，在没有设置width属性的宽度的情况下会参照元素的content的宽度 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 100%; height: 500px; background-color: #ccc; margin:0 auto; /*设置父容器的为伸缩盒子*/ display: flex; /*设置子元素在主轴方向上的排列方式*/ /*justify-content: flex-start;*/ &#125; .left&#123; /*flex是用来设置当前伸缩子项占据剩余空间的比例值*/ flex: 1; height: 500px; background-color: red; &#125; .right&#123; flex: 4; height: 500px; background-color: blue; &#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940/*案例：伸缩菜单项*/&lt;div&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;商品分类&lt;/li&gt; &lt;li&gt;我的订单&lt;/li&gt; &lt;li&gt;最新商品&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 500px; height: 400px; border: 1px solid #ccc; margin:100px auto; &#125; div &gt; ul&#123; list-style: none; width: 100%; /*将父容器设置了伸缩盒子，子元素默认成为伸缩项 float margin*/ display: flex; &#125; div &gt; ul &gt; li&#123; /*宽度 1.我们并不知道li的具体的数量 2.也不直接设置%*/ height: 36px; line-height: 36px; text-align: center; background-color: #9fff9d; border-right: 1px solid #ccc; flex: 1; &#125;&lt;/style&gt; 9、align-items调整侧轴对齐（垂直对齐） 子盒子如何在父盒子里面垂直对齐（单行） 值 描述 白话文 stretch 默认值。项目被拉伸以适应容器。 让子元素的高度拉伸适用父容器（子元素不给高度的前提下) center 项目位于容器的中心。 垂直居中 flex-start 项目位于容器的开头。 垂直对齐开始位置 上对齐 flex-end 项目位于容器的结尾。 垂直对齐结束位置 底对齐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;first&quot;&gt;bb&lt;/div&gt; &lt;div class=&quot;second&quot; style=&quot;font-size: 100px&quot;&gt;gg&lt;/div&gt; &lt;div class=&quot;third&quot;&gt;klkaslg&lt;/div&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 900px; height: 600px; border: 1px solid red; margin:0 auto; /*设置父容器为盒子：会使每一个子元素自动变成伸缩项 当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/ display: flex; /*设置子元素的主轴方向上的排列方式*/ justify-content: space-around; /*align-items:设置子元素(伸缩项)在侧轴方向上的对齐方式 center:设置在侧轴方向上居中对齐 flex-start:设置在侧轴方向上顶对齐 flex:end:设置在侧轴方向上底对齐 stretch:拉伸：让子元素在侧轴方向上进行拉伸，填充满整个侧轴方向&gt;&gt; 默认值 baseline:文本基线*/ align-items: center; &#125; .first &#123; width: 200px; height: 200px; background-color: red; align-self: flex-start; &#125; .second&#123; width: 200px; height: 200px; background-color: green; /*设置单个元素在侧轴方向上的对齐方式*/ align-self: flex-end; &#125; .third&#123; width: 200px; height: 200px; background-color: blue; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*自适应布局案例*/&lt;div class=&quot;layout&quot;&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .layout&#123; width: 500px; height: 600px; background-color: #CCCCCC; margin:10px auto; /*设置父容器为伸缩盒子*/ display: flex; /*默认的主轴是row,这里需要以列的方式进行排列*/ flex-direction: column; &#125; header&#123; width: 100%; height: 60px; background-color: red; &#125; main&#123; width: 100%; background-color: green; /*让当前伸缩项占据父容器的剩余空间*/ flex: 1; /*让main成为伸缩盒子*/ display: flex; &#125; main &gt; article&#123; height: 100%; flex: 1; background-color: pink; &#125; main &gt; aside&#123; height: 100%; flex: 3; background-color: darkblue; &#125; footer&#123; width: 100%; height: 80px; background-color: purple; &#125;&lt;/style&gt; 10、align-content（由flex-wrap产生的独立行）多行垂直对齐方式 align-content是针对flex容器里面多轴(多行)的情况，align-items是针对一行的情况进行排列。 必须对父元素设置自由盒属性display:flex;，并且设置排列方式为横向排列flex-direction:row;并且设置换行，flex-wrap:wrap;这样这个属性的设置才会起作用。 值 描述 测试 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;father&quot;&gt; &lt;div class=&quot;son1&quot;&gt;q&lt;/div&gt; &lt;div class=&quot;son2&quot;&gt;w&lt;/div&gt; &lt;div class=&quot;son3&quot;&gt;e&lt;/div&gt; &lt;div class=&quot;son3&quot;&gt;e&lt;/div&gt; &lt;div class=&quot;son3&quot;&gt;e&lt;/div&gt;&lt;/div&gt;&lt;style&gt; #father&#123; width:200px; display:flex; flex-direction:row; flex-wrap:wrap; align-content:strech; height:200px; background-color:grey; &#125; .son1&#123; height:30px; width:100px; background-color:orange; &#125; .son2&#123; height:30px; width:100px; background-color:red; &#125; .son3&#123; height:30px; width:100px; background-color:#08a9b5; &#125;&lt;/style&gt; 11、order控制子项目的排列顺序，正序方式排序，从小到大 用css 来控制盒子的前后顺序。 用order 就可以 用整数值来定义排列顺序，数值小的排在前面。可以为负值。 默认值是 0 1order: 1; https://www.cnblogs.com/xuyuntao/articles/6391728.html 案例：flex布局携程首页 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;../images/banner.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/header&gt; &lt;main&gt; &lt;section class=&quot;item&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;团购&lt;/a&gt; &lt;a href=&quot;&quot;&gt;特惠酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;item&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;团购&lt;/a&gt; &lt;a href=&quot;&quot;&gt;特惠酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;item&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;团购&lt;/a&gt; &lt;a href=&quot;&quot;&gt;特惠酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;item&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;团购&lt;/a&gt; &lt;a href=&quot;&quot;&gt;特惠酒店&lt;/a&gt; &lt;a href=&quot;&quot;&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;extra&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;../images/extra_1.png&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;../images/extra_2.png&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/section&gt; &lt;/main&gt; &lt;footer&gt; &lt;nav&gt; &lt;a href=&quot;&quot;&gt;电话预订&lt;/a&gt; &lt;a href=&quot;&quot;&gt;下载客户端&lt;/a&gt; &lt;a href=&quot;&quot;&gt;我的订单&lt;/a&gt; &lt;/nav&gt; &lt;p class=&quot;link&quot;&gt; &lt;a href=&quot;&quot;&gt;网站地图&lt;/a&gt; &lt;a href=&quot;&quot;&gt;ENGLISH&lt;/a&gt; &lt;a href=&quot;&quot;&gt;电脑版&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;copyRight&quot;&gt;&amp;copy;2015 携程旅行&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt;&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; /*顶部块样式*/ header&#123; width: 100%; /*设置为伸缩盒子*/ display: flex; &#125; header &gt; a&#123; /*width: 100%;*/ /*flex:设置当前子元素占据父容器剩余宽度的比例 如果没有其他兄弟元素，则flex:1会占据整个父容器 */ flex: 1; &#125; header &gt; a &gt; img&#123; width: 100%; /*让img的宽度和a标签的宽度一致*/ &#125; /*主体内容块样式*/ main&#123; width: 100%; padding:0 10px; /*设置盒模型，如果不设置,main的宽度会+20 */ box-sizing: border-box; &#125; main &gt; .item&#123; width: 100%; height: 100px; background-color: #57c3ae; border-radius: 10px; margin-top:10px; /*设置为伸缩盒子*/ display: flex; &#125; main &gt; .item &gt; .left&#123; flex: 1; /*left占据三分之一*/ &#125; main &gt; .item &gt; .right&#123; flex: 2;/*right占据三分之二*/ /*设置换行显示*/ flex-wrap: wrap; /*设置为伸缩盒子，伸缩盒子之后子元素可以在一行显示*/ display: flex; &#125; main &gt; .item &gt; .right &gt; a&#123; /*如果想让子元素换行显示，必须为子元素设置宽度*/ width: 50%; box-sizing: border-box;/*这边需要设置border-box,因为a标签的宽度是50%,两个a标签就占据100%的宽度，此时再加上boder-left的1px，导致一行放不下两个a，布局出现问题*/ border-left: 1px solid #fff; border-bottom: 1px solid #fff; display: block; color: #fff; line-height: 50px; text-align: center; text-decoration: none; &#125; /*找到第二个、第三个、第四个item设置样式*/ main &gt; .item:nth-of-type(2)&#123; background-color: #33aa46; &#125; main &gt; .item:nth-of-type(3)&#123; background-color: #aa4b40; &#125; main &gt; .item:nth-of-type(4)&#123; background-color: #445faa; &#125; /*取倒数两个a*/ main &gt; .item &gt; .right &gt; a:nth-last-of-type(-n+2)&#123; border-bottom:none &#125; /*设置extra为伸缩盒子*/ main &gt; .extra&#123; width: 100%; display: flex; &#125; main &gt; .extra &gt; a&#123; flex: 1;/*a的权重是1*/ &#125; main &gt; .extra &gt; a &gt; img&#123; width: 100%; &#125; /*底部块样式*/ footer&#123; width: 100%; font-size: 13px; &#125; footer &gt; nav&#123; width: 100%; display: flex; border-top:1px solid #ccc; border-bottom:1px solid #ccc; &#125; footer &gt; nav &gt; a&#123; flex: 1; line-height: 30px; text-align: center; color: #888; text-decoration: none; &#125; footer &gt; .link&#123; text-align: center; line-height: 25px; &#125; footer &gt; .copyRight&#123; text-align: center; &#125;&lt;/style&gt; 全屏插件的使用fullPage.js 是一个基于 jQuery 的插件，它能够帮你很方便、很轻松的制作出全屏网站。 github 官网 https://github.com/alvarotrigo/fullPage.js 中文演示地址 http://www.dowebok.com/demo/2014/77/ 123456789##主要功能有：支持鼠标滚动支持前进后退和键盘控制多个回调函数支持手机、平板触摸事件支持 CSS3 动画支持窗口缩放窗口缩放时自动调整可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等 fullpage 详细参数 选项 类型 默认值 说明 verticalCentered 字符串 true 内容是否垂直居中 resize 布尔值 false 字体是否随着窗口缩放而缩放 sectionColor 函数 无 设置背景颜色 anchors 数组 无 定义锚链接 scrollingSpeed 整数 700 滚动速度，单位为毫秒 easing 字符串 easeInQuart 滚动动画方式 menu 布尔值 false 绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动 navigation 布尔值 false 是否显示项目导航 navigationPosition 字符串 right 项目导航的位置，可选 left 或 right navigationTooltips 数组 空 项目导航的 tip slidesNavigation 布尔值 false 是否显示左右滑块的项目导航 slidesNavPosition 字符串 bottom 左右滑块的项目导航的位置，可选 top 或 bottom controlArrowColor 字符串 #fff 左右滑块的箭头的背景颜色 loopBottom 布尔值 false 滚动到最底部后是否滚回顶部 loopTop 布尔值 false 滚动到最顶部后是否滚底部 loopHorizontal 布尔值 true 左右滑块是否循环滑动 autoScrolling 布尔值 true 是否使用插件的滚动方式，如果选择 false，则会出现浏览器自带的滚动条 scrollOverflow 布尔值 false 内容超过满屏后是否显示滚动条 css3 布尔值 false 是否使用 CSS3 transforms 滚动 paddingTop 字符串 0 与顶部的距离 paddingBottom 字符串 0 与底部距离 fixedElements 字符串 无 normalScrollElements 无 keyboardScrolling 布尔值 true 是否使用键盘方向键导航 touchSensitivity 整数 5 continuousVertical 布尔值 false 是否循环滚动，与 loopTop 及 loopBottom 不兼容 animateAnchor 布尔值 true normalScrollElementTouchThreshold 整数 5 fullPage.js 方法注意方法的使用时需要添加：$.fn.fullpage 1比如:$.fn.fullpage.moveTo(1); 名称 说明 moveSectionUp() 向上滚动 moveSectionDown() 向下滚动 moveTo(section, slide) 滚动到 moveSlideRight() slide 向右滚动 moveSlideLeft() slide 向左滚动 setAutoScrolling() 设置页面滚动方式，设置为 true 时自动滚动 setAllowScrolling() 添加或删除鼠标滚轮&#x2F;触控板控制 setKeyboardScrolling() 添加或删除键盘方向键控制 setScrollingSpeed() 定义以毫秒为单位的滚动速度 回调函数 名称 说明 afterLoad 滚动到某一屏后的回调函数，接收 anchorLink 和 index 两个参数，anchorLink 是锚链接的名称，index 是序号，从1开始计算 onLeave 滚动前的回调函数，接收 index、nextIndex 和 direction 3个参数：index 是离开的“页面”的序号，从1开始计算；nextIndex 是滚动到的“页面”的序号，从1开始计算；direction 判断往上滚动还是往下滚动，值是 up 或 down。 afterRender 页面结构生成后的回调函数，或者说页面初始化完成后的回调函数 afterSlideLoad 滚动到某一水平滑块后的回调函数，与 afterLoad 类似，接收 anchorLink、index、slideIndex、direction 4个参数 onSlideLeave 某一水平滑块滚动前的回调函数，与 onLeave 类似，接收 anchorLink、index、slideIndex、direction 4个参数 123456789101112131415161718192021222324252627282930$(document).ready(function() &#123; $(&#x27;#fullpage&#x27;).fullpage(&#123; sectionsColor: [&#x27;#1bbc9b&#x27;, &#x27;#4BBFC3&#x27;, &#x27;#7BAABE&#x27;, &#x27;#f90&#x27;,&quot;#abc123&quot;], //当垂直方向滚动完毕之后触发afterLoad afterLoad: function(anchorLink, index)&#123; /*anchorLink : 锚点连接的名字index ：第几屏*/ console.log(&quot;afterLoad&quot;); &#125;, //当垂直方向发生滚动的时候出发onLeave onLeave: function(index, direction)&#123; console.log(&quot;onLeave&quot;); if(index == 2)&#123; //禁止滚动 $.fn.fullpage.setAllowScrolling(false,&quot;down&quot;); &#125; &#125;, //当水平方向滚动完毕的时候触发afterSlideLoad afterSlideLoad: function(anchorLink, index, slideAnchor, slideIndex)&#123; //index : 表示当前是第几屏 //slideIndex : 表示当前水平方向是第几个页面 console.log(index,slideIndex); &#125;, afterRender: function()&#123; console.log(&quot;afterRender&quot;); &#125; &#125;);&#125;); 基本使用案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546//参照 jQuery全屏滚动插件fullPage.js_dowebok.html//要实现滚动到某一屏之后执行动画，可以使用afterLoad&lt;div id=&quot;dowebok&quot;&gt; &lt;!--每一个section就是一屏--&gt; &lt;div class=&quot;section first&quot;&gt; &lt;h3&gt;第一屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;section second&quot;&gt; &lt;h3&gt;第二屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;section&quot;&gt; &lt;h3&gt;第三屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;section&quot;&gt; &lt;h3&gt;第四屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;section&quot;&gt; &lt;h3&gt;第5屏&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.first.current h3&#123; font-size: 100px;&#125;/*交集选择器：当前元素同时添加了second和current的时候才会有效果*/.second.current h3&#123; font-size: 100px;&#125;&lt;/style&gt;$(function()&#123; $(&#x27;#dowebok&#x27;).fullpage(&#123; /*设置每一屏的背景色*/ sectionsColor:[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;pink&quot;,&quot;skyBlue&quot;], /*当滚动到某一屏之后调用 * index:当前屏的索引，索引从1开始*/ afterLoad:function(anchorLink,index)&#123; /*将其它屏的current标记移除*/ $(&quot;.section&quot;).removeClass(&quot;current&quot;); //alert(index); /*添加样式,当滚动到某一屏之后，为元素添加样式--标记*/ $(&quot;.section&quot;).eq(index-1).addClass(&quot;current&quot;); &#125; &#125;);&#125;); 案例：360全屏网站制作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&lt;div id=&quot;360Page&quot;&gt; &lt;div class=&quot;section first&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;text&quot;&gt; &lt;img src=&quot;../images/text_1.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_2.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_3.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_4.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_5.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_6.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_7.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/text_8.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;intro&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section second&quot;&gt; &lt;div class=&quot;shield&quot;&gt; &lt;img src=&quot;../images/shield_1.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_2.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_3.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_4.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_5.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_6.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_7.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_8.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;../images/shield_9.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section third&quot;&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt; &lt;div class=&quot;rocket&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section fourth&quot;&gt; &lt;div class=&quot;search&quot;&gt; &lt;div class=&quot;searchBar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;searchText&quot;&gt;&lt;/div&gt; &lt;div class=&quot;searchResult&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section fifth&quot;&gt; &lt;h3&gt;第5屏&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function()&#123; $(&#x27;#360Page&#x27;).fullpage(&#123; /*设置每一屏的背景色*/ sectionsColor:[&#x27;#0da5d6&#x27;, &#x27;#2AB561&#x27;, &#x27;#DE8910&#x27;, &#x27;#16BA9D&#x27;, &#x27;#0DA5D6&#x27;], /*滚动到某一屏之后的回调 * index:当前屏的索引，索引从1开始*/ afterLoad:function(anchorLink,index)&#123; /*将其它屏的current样式标记清除*/ $(&quot;.section&quot;).removeClass(&quot;current&quot;); setTimeout(function()&#123; /*当滚动到某一个屏之后，添加样式标记*/ $(&quot;.section&quot;).eq(index-1).addClass(&quot;current&quot;);&#125;,500); &#125; &#125;); &#125;);&lt;/script&gt;*&#123; padding: 0; margin: 0;&#125;#360Page&#123;&#125;.section&#123; overflow: hidden;/*内容超出当前屏，隐藏*/&#125;/*第一屏样式*/.first&#123; padding-top:80px;&#125;/*插件会默认为所有内容添加一个父容器，意味着logo并不是first的直接子元素*/.first .logo&#123; background: url(&quot;../images/logo.png&quot;); height: 186px; width: 251px; margin:0 auto;&#125;.first .text&#123; width: 100%; text-align: center; margin-top:80px;&#125;.first .text &gt; img&#123; margin:0 40px; opacity: 0.2; /*添加过渡效果 margin在1秒内完成，opacity在1秒内完成*/ transition: margin 1s,opacity 1s;&#125;.first .intro&#123; background: url(&quot;../images/info_1.png&quot;); height: 49px; width: 772px; margin:40px auto;&#125;/*添加一个交集选择器，用来做动画*/.first.current .text &gt; img&#123; margin:0 5px; opacity: 1;&#125;/*第二屏样式 : 伸缩盒子*/.second&#123;&#125;/*设置second里面的div为伸缩盒子 。不直接设置second为伸缩盒子原因是全屏插件会自动帮我们在second下生成一个子div */.second &gt; div &#123; display: flex; /*设置主轴方向上的排列方式*/ justify-content: space-around; /*设置侧轴方向上的排列方式*/ align-items: center;&#125;.second .shield&#123; width: 440px; font-size: 0;&#125;.second .info&#123; height: 309px; width: 635px; background: url(&quot;../images/info_2.png&quot;);&#125;.second .shield &gt; img&#123; /*添加过渡效果*/ transition: transform 1s;&#125;.second .shield &gt; img:nth-of-type(1)&#123; transform: translate(100px,100px) rotate(30deg);&#125;.second .shield &gt; img:nth-of-type(2)&#123; transform: translate(-100px,-100px) rotate(-30deg);&#125;.second .shield &gt; img:nth-of-type(3)&#123; transform: translate(200px,200px) rotate(60deg);&#125;.second .shield &gt; img:nth-of-type(4)&#123; transform: translate(-200px,-200px) rotate(-60deg);&#125;.second .shield &gt; img:nth-of-type(5)&#123; transform: translate(150px,150px) rotate(90deg);&#125;.second .shield &gt; img:nth-of-type(6)&#123; transform: translate(50px,150px) rotate(-90deg);&#125;.second .shield &gt; img:nth-of-type(7)&#123; transform: translate(-150px,-150px) rotate(60deg);&#125;.second .shield &gt; img:nth-of-type(8)&#123; transform: translate(10px,-250px) rotate(-90deg);&#125;.second .shield &gt; img:nth-of-type(9)&#123; transform: translate(-250px,10px) rotate(45deg);&#125;/*添加第二屏过渡效果*/.second.current .shield &gt; img&#123; /*清除默认添加的transform*/ transform: none;&#125;/*第三屏样式：通过观察窗口大小变化，可以发现图片是相对于页面中心来定位的 子绝父相*/.third&#123; position: relative;&#125;.third .info&#123; height: 278px; width: 631px; background: url(&quot;../images/info_3.png&quot;); position: absolute; /*定位的参照是参照父容器的宽高*/ left: 50%; top: 50%; /*transform的translate是相对于元素本身的宽高*/ transform:translate(-100%,-50%);&#125;.third .circle&#123; height: 449px; width: 453px; background: url(&quot;../images/circle.png&quot;); position: absolute; right: 50%; top: 50%; transform:translate(120%,-50%);&#125;.third .circle &gt; .rocket&#123; height: 204px; width: 203px; background: url(&quot;../images/rocket.png&quot;); position: absolute; left: -600px; top: 650px; /*添加过渡*/ transition: left 1s,top 1s;&#125;/*添加第三屏动画*/.third.current .circle &gt; .rocket&#123; left: 125px; top: 125px;&#125;/*第四屏样式 ： 相对于屏幕正中心定位，和第三屏一样*/.fourth&#123; position: relative;&#125;.fourth .search&#123; width: 529px; height: 438px; position: absolute; left: 50%; top: 50%; transform: translate(-115%,-50%); overflow: hidden;&#125;.fourth .search &gt; .searchBar&#123; width: 529px; height: 66px; background: url(&quot;../images/search.png&quot;); /*开始时，搜索框不可见，所以可以进行默认的偏移*/ transform: translateX(-100%);&#125;.fourth .search &gt; .searchText&#123; /*开始时，文本不可见*/ width: 0px; height: 22px; background: url(&quot;../images/key.png&quot;); position: absolute; left: 15px; top: 20px;&#125;.fourth .search &gt; .searchResult&#123; width: 529px; /*搜索结果默认不可见*/ height: 0px; background: url(&quot;../images/result.png&quot;); margin-top:-12px;&#125;.fourth .info&#123; width: 612px; height: 299px; background: url(&quot;../images/info_4.png&quot;); position: absolute; right: 50%; top: 50%; transform:translate(100%,-50%);&#125;/*第四屏过渡效果的实现*/.fourth.current .search &gt; .searchBar&#123; transform: translateX(0%); /*添加过渡样式*/ transition: transform 1s;&#125;.fourth.current .search &gt; .searchText&#123; width: 99px; transition: width 1s 1s steps(5);/*延迟1秒，花1秒钟把宽度由0到99，分5步完成*/&#125;.fourth.current .search &gt; .searchResult&#123; height: 372px; transition: height 1s 2s; /*延迟2秒，花1秒钟将height由0变成372px*/&#125;","categories":[],"tags":[]},{"title":"","slug":"05 Web API","date":"2022-03-09T09:49:27.173Z","updated":"2022-03-02T07:48:00.000Z","comments":true,"path":"2022/03/09/05 Web API/","link":"","permalink":"http://example.com/2022/03/09/05%20Web%20API/","excerpt":"","text":"1.Web API介绍1.1 API的概念API（**Application Programming Interface**,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 任何开发语言都有自己的API API的特征输入和输出(I&#x2F;O) API的使用方法(console.log()) 1.2 Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) 此处的Web API特指浏览器提供的API(一组方法)。 Web API在后面的课程中有其它含义(网络应用程序接口。它包含了广泛的功能，网络应用通过API接口，可以实现存储服务、消息服务、计算服务的能力，利用这些能力可以进行开发出强大功能的web应用 B&#x2F;S C&#x2F;S。) 1.3 掌握常见的浏览器提供的API的调用方式MDN-Web API 1.4 JavaScript的组成 1.4.1 ECMAScript - JavaScript的核心定义了javascript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 1.4.2 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 1.4.3 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 2. DOM2.1 DOM的概念文档对象模型（Document Object Model，简称DOM），是[W3C](http://baike.baidu.com/item/W3C)组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 Document Object Model的历史可以追溯至1990年代后期微软与[Netscape](http://baike.baidu.com/item/Netscape)的“浏览器大战”，双方为了在[JavaScript](http://baike.baidu.com/item/JavaScript)与[JScript](http://baike.baidu.com/item/JScript)一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有[VBScript](http://baike.baidu.com/item/VBScript)、[ActiveX](http://baike.baidu.com/item/ActiveX)、以及微软自家的[DHTML](http://baike.baidu.com/item/DHTML)格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。 DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 2.2 为什么要DOM万物皆对象，有了对象支持通过对象的方式来获取修改元素。如果没有DOM对象，那么要找到页面上某个元素，只能通过字符串查找的方式，太过麻烦，费时费力。 2.3 DOM可以做什么 获取元素 动态创建元素 对元素进行操作(设置其属性或调用其方法) 事件(什么时机做相应的操作) 2.4 添加事件的三种方式123456789101112131415161718192021222324252627//1.初级方案&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; onclick=&quot;alert(&#x27;我被点了&#x27;)&quot; /&gt;//2.中级方案&lt;script&gt; function f1() &#123; alert(&quot;这是一个对话框&quot;); &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; onclick=&quot;f1()&quot;/&gt;//3.最终方案：使用dom对象进行事件分配&lt;input type=&quot;button&quot; value=&quot;开始分离代码&quot; id=&quot;btn1&quot; /&gt;// //根据id属性的值从整个文档中获取这个元素(标签)var btnObj1=document.getElementById(&quot;btn1&quot;); //为该元素注册点击事件btnObj1.onclick=function () &#123; alert(&quot;哦,这真是太好了&quot;);&#125;;//根据id属性的值从整个文档中获取这个元素(标签)//为该元素注册点击事件document.getElementById(&quot;btn1&quot;).onclick=function () &#123; alert(&quot;哦,这真是太好了&quot;);&#125;;//注意 : &lt;script&gt;标签在body前后位置带来的影响 3. 获取页面元素3.1 为什么要获取页面元素例如：我们想要操作页面上的某部分(显示&#x2F;隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 3.2 根据id获取元素12345var div = document.getElementById(&#x27;main&#x27;);console.log(div);// 获取到的数据类型 HTMLDivElement，对象都是有类型的// HTMLDivElement &lt;-- HTMLElement &lt;-- Element &lt;-- Node &lt;-- EventTarget 注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。 3.3 根据标签名获取元素12345var divs = document.getElementsByTagName(&#x27;div&#x27;);for (var i = 0; i &lt; divs.length; i++) &#123; var div = divs[i]; console.log(div);&#125; 3.4 根据name获取元素12345var inputs = document.getElementsByName(&#x27;hobby&#x27;);for (var i = 0; i &lt; inputs.length; i++) &#123; var input = inputs[i]; console.log(input);&#125; 3.5 根据类名获取元素123456//h5，IE9之后支持var mains = document.getElementsByClassName(&#x27;main&#x27;);for (var i = 0; i &lt; mains.length; i++) &#123; var main = mains[i]; console.log(main);&#125; 3.6 根据选择器获取元素12345678var text = document.querySelector(&#x27;#text&#x27;);console.log(text);var boxes = document.querySelectorAll(&#x27;.box&#x27;);for (var i = 0; i &lt; boxes.length; i++) &#123; var box = boxes[i]; console.log(box);&#125; 3.7 getElementsByTagName和querySelector的区别1234567//1.区别getElementsByTagName获取的是动态集合，querySelector获取的是静态集合。简单的说就是，动态就是选出的元素会随文档改变，静态的不会，取出来之后就和文档的改变无关了。//2.应用场景如果只要一次查找就可得到元素时，首选querySelector ；如果需要经过多级查找，才能得到元素时，用getElementsByTagName； 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; var ul = document.getElementsByTagName(&#x27;ul&#x27;)[0]; lis = ul.getElementsByTagName(&quot;li&quot;); ul.appendChild(document.createElement(&quot;li&quot;)); console.log( lis.length); //4&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var ul = document.getElementsByTagName(&#x27;ul&#x27;)[0]; var lis = document.querySelectorAll(&#x27;li&#x27;); ul.appendChild(document.createElement(&quot;li&quot;)); console.log( lis.length); //3&lt;/script&gt; 3.8 总结12345678910111213141516171819//根据id属性的值获取元素,返回来的是一个元素对象* document.getElementById(&quot;id属性的值&quot;);//根据标签名字获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象* document.getElementsByTagName(&quot;标签名字&quot;);//下面的几个,有的浏览器不支持//根据name属性的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象* document.getElementsByName(&quot;name属性的值&quot;)//根据类样式的名字来获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象* document.getElementsByClassName(&quot;类样式的名字&quot;)//根据选择器获取元素,返回来的是一个元素对象* document.querySelector(&quot;选择器的名字&quot;);//根据选择器获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象* document.querySelectorAll(&quot;选择器的名字&quot;) 4. 属性操作4.1 非表单元素的属性 href、title、id、src 1234567891011121314&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;baidu&quot; id=&quot;link&quot;&gt;点我&lt;/a&gt;var link = document.getElementById(&#x27;link&#x27;);//通过console.dir(link) 可以查看该a节点对象的所有信息//通过打印我们发现除了title和href属性之外，document文档对象模型还帮我们封装了其他很多属性console.dir(link);console.log(link.href);console.log(link.title);console.log(link.host);var pic = document.getElementById(&#x27;pic&#x27;);console.log(pic.src);//我们也可以直接通过link.href = &quot;xx&quot;来给属性赋值 innerText&#x2F;textContent&#x2F;innerHTML&#x2F;value a) textContent和innerText的区别 textContent : 设置标签中的文本内容,谷歌,火狐支持,IE8不支持 innerText : 设置标签中的文本内容,谷歌,火狐,IE8都支持 如果这个属性在浏览器中不支持,那么这个属性的类型是undefined，所以判断这个属性的类型是不是 undefined,就知道浏览器是否支持。 1234567891011121314151617181920//设置任意的标签中间的任意文本内容function setInnerText(element,text) &#123; //判断浏览器是否支持这个属性 if(typeof element.textContent ==&quot;undefined&quot;)&#123; //不支持 element.innerText=text; &#125;else&#123; //支持这个属性 element.textContent=text; &#125;&#125;//获取任意标签中间的文本内容function getInnerText(element) &#123; if(typeof element.textContent==&quot;undefined&quot;)&#123; return element.innerText; &#125;else&#123; return element.textContent; &#125;&#125; b) innerText和innerHTML的区别 如果使用innerText主要是设置和获取文本的,设置标签内容,是没有标签的效果的 innerHTML主要的作用是在标签中设置新的html或者获取html标签内容,是有标签效果的 1234567891011121314my$(&quot;btn&quot;).onclick=function () &#123; my$(&quot;dv&quot;).innerText=&quot;哈哈&quot;;//设置文本 my$(&quot;dv&quot;).innerText=&quot;&lt;p&gt;这是一个p&lt;/p&gt;&quot;;//设置html标签的代码 my$(&quot;dv&quot;).innerHTML=&quot;哈哈&quot;; my$(&quot;dv&quot;).innerHTML=&quot;&lt;p&gt;这是一个p&lt;/p&gt;&quot;;//设置Html标签的 &#125;; //获取 my$(&quot;btn2&quot;).onclick=function () &#123; //可以获取标签中的文本内容 console.log(my$(&quot;dv&quot;).innerText); console.log(my$(&quot;dv&quot;).innerHTML); &#125;; c) value : 主要是用来给value属性赋值 类名操作 : 修改标签的className属性相当于直接修改标签的类名 12var box = document.getElementById(&#x27;box&#x27;);box.className = &#x27;clearfix&#x27;; 4.2 样式操作12345678910111213//1、获取行内（内嵌、行间）样式： obj.style.attr;进行获取非行间样式。//2、设置行内样式： obj.style.attr = value;//3、举例： var box = document.getElementById(&#x27;box&#x27;); box.style.width = &#x27;100px&#x27;; box.style.height = &#x27;100px&#x27;; box.style.backgroundColor = &#x27;red&#x27;; //通过样式属性设置宽高、位置的属性类型是字符串，需要加上px 4.3 案例1.点击按钮显示图片 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;显示图片&quot; id=&quot;btn&quot;/&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;im&quot; /&gt;//根据id获取按钮, var btnObj=document.getElementById(&quot;btn&quot;); //为按钮注册点击事件,添加事件处理函数 btnObj.onclick=function () &#123; //根据id获取图片的标签,设置图片的src属性值 var imObj=document.getElementById(&quot;im&quot;); imObj.src=&quot;images/liuyan.jpg&quot;; //设置图片的大小 //直接设置属性值，无需加单位px imObj.width=&quot;300&quot;; imObj.height=&quot;400&quot;; &#125;; 2.点击按钮修改p标签中的内容 123456//根据id获取按钮,为按钮注册点击事件,添加事件处理函数document.getElementById(&quot;btn&quot;).onclick=function () &#123; //根据id获取p标签,设置内容 //凡是成对的标签,中间的文本内容,设置的时候,都使用innerText这个属性的方式 document.getElementById(&quot;p1&quot;).innerText=&quot;这是一个p&quot;;&#125;; 3.点击按钮修改a标签的链接和文字 1234567document.getElementById(&quot;btn&quot;).onclick = function () &#123; //根据id获取超链接,设置href属性 var aObj = document.getElementById(&quot;ak&quot;); aObj.href = &quot;http://www.baidu.cn&quot;; //根据id获取超链接,设置文字内容 aObj.innerText = &quot;学习前端真快乐&quot;;&#125;; 4.点击(每个)图片弹出对话框 12345678910111213141516171819202122232425&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot; id=&quot;im1&quot; /&gt;&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot; id=&quot;im2&quot; /&gt;&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot; id=&quot;im3&quot; /&gt;//1.分别绑定事件document.getElementById(&quot;im1&quot;).onclick=function () &#123; alert(&quot;被点了&quot;);&#125;;document.getElementById(&quot;im2&quot;).onclick=function () &#123; alert(&quot;被点了&quot;);&#125;;document.getElementById(&quot;im3&quot;).onclick=function () &#123; alert(&quot;被点了&quot;);&#125;;//2.获取到所有标签，循环绑定事件//根据标签的名字获取图片标签,分别注册点击事件var imgObjs=document.getElementsByTagName(&quot;img&quot;); //循环遍历数组,获取每个图片标签,注册点击事件,添加事件处理函数 for(var i=0;i&lt;imgObjs.length;i++)&#123; imgObjs[i].onclick=function () &#123; alert(&quot;被点击了&quot;); &#125;;&#125; 5.点击按钮修改value属性值 123456789&lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;btn&quot;/&gt; var btnObj = document.getElementById(&quot;btn&quot;);btnObj.onclick = function () &#123; //修改按钮的value属性 this.value=&quot;我是按钮,谁咬我,我就咬谁&quot;; this.type=&quot;text&quot;; this.id=&quot;btn2&quot;;&#125;; 6.点击按钮修改每个图片的title属性 123456789&lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;btn&quot;/&gt; document.getElementById(&quot;btn&quot;).onclick = function () &#123; //返回的是一个伪数组 //伪数组具备length 、按索引存储数据、遍历等行为，但是不具备数组的方法，比如push() pop()等 var imgObjs = document.getElementsByTagName(&quot;img&quot;); imgObjs[0].alt = &quot;改了&quot;; imgObjs[0].title = &quot;现实吧&quot;;&#125;; 7.点击图片修改自身的宽和高 123456789&lt;img src=&quot;images/liuyan.jpg&quot; alt=&quot;&quot; id=&quot;im&quot;/&gt; //点击图片,修改自身的宽和高var imgObj = document.getElementById(&quot;im&quot;);imgObj.onclick = function () &#123; //直接使用自身属性，不需要px this.width = &quot;200&quot;; this.height = &quot;300&quot;;&#125;; 8.点击按钮修改所有p标签内容 12345678910111213141516171819202122232425262728&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv1&quot;&gt; &lt;p&gt;哈哈,我又变帅了&lt;/p&gt; &lt;p&gt;哈哈,我又变帅了&lt;/p&gt; &lt;p&gt;哈哈,我又变帅了&lt;/p&gt; &lt;p&gt;哈哈,我又变帅了&lt;/p&gt; &lt;p&gt;哈哈,我又变帅了&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;dv2&quot;&gt; &lt;p&gt;嘎嘎&lt;/p&gt; &lt;p&gt;嘎嘎&lt;/p&gt; &lt;p&gt;嘎嘎&lt;/p&gt; &lt;p&gt;嘎嘎&lt;/p&gt;&lt;/div&gt;//案例:点击按钮设置多个p标签的文字内容//根据id获取按钮,注册点击事件,添加事件处理函数document.getElementById(&quot;btn&quot;).onclick=function () &#123; //根据标签名字获取标签 var pObjs= document.getElementsByTagName(&quot;p&quot;); //var pObjs=document.getElementById(&quot;dv1&quot;).getElementsByTagName(&quot;p&quot;); //循环遍历这个数组 for(var i=0;i&lt;pObjs.length;i++)&#123; //每个p标签,设置文字 pObjs[i].innerText=&quot;我们都是p&quot;; &#125;&#125;; 9.点击按钮修改所有文本框内容 123456789101112131415161718192021&lt;input type=&quot;button&quot; value=&quot;修改文本框的值&quot; id=&quot;btn&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;&quot;/&gt;&lt;br/&gt;//根据id获取按钮,为按钮注册点击事件,添加事件处理函数document.getElementById(&quot;btn&quot;).onclick = function () &#123; //获取所有的文本框 var inputs = document.getElementsByTagName(&quot;input&quot;); for (var i = 0; i &lt; inputs.length; i++) &#123; //判断这个元素是不是按钮 if (inputs[i].type != &quot;button&quot;) &#123; inputs[i].value = &quot;呵呵，天亮了&quot;; &#125; &#125;&#125;; 10.按钮排他性 123456789101112131415161718192021&lt;input type=&quot;button&quot; value=&quot;没怀孕&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;没怀孕&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;没怀孕&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;没怀孕&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;没怀孕&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;没怀孕&quot;/&gt;//获取所有的按钮,分别注册点击事件var btnObjs = document.getElementsByTagName(&quot;input&quot;);//循环遍历所有的按钮for (var i = 0; i &lt; btnObjs.length; i++) &#123; //为每个按钮都要注册点击事件 btnObjs[i].onclick = function () &#123; //把所有的按钮的value值设置为默认的值:没怀孕 for (var j = 0; j &lt; btnObjs.length; j++) &#123; btnObjs[j].value = &quot;没怀孕&quot;; &#125; //当前被点击的按钮设置为:怀孕了 this.value = &quot;怀孕了&quot;; &#125;;&#125; 11.点击按钮修改图片 123456789&lt;input type=&quot;button&quot; value=&quot;显示大图&quot; id=&quot;btn&quot;/&gt;&lt;img src=&quot;images/1-small.jpg&quot; alt=&quot;&quot; id=&quot;im&quot;&gt;function my$(id) &#123; return document.getElementById(id);&#125;my$(&quot;btn&quot;).onclick=function () &#123; my$(&quot;im&quot;).src=&quot;images/1.jpg&quot;;&#125;; 12.点击按钮设置宽高 123456789//点击按钮,修改div的宽,高,背景颜色my$(&quot;btn&quot;).onclick = function () &#123; //使用css属性，值要px my$(&quot;dv&quot;).style.width = &quot;300px&quot;; my$(&quot;dv&quot;).style.height = &quot;200px&quot;; //css --&gt;background-color //js --&gt;backgroundColor my$(&quot;dv&quot;).style.backgroundColor = &quot;pink&quot;;&#125;; 13.点击按钮切换显示和隐藏 1234567891011121314&lt;input type=&quot;button&quot; value=&quot;隐藏&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;//根据id获取按钮,注册点击事件,添加事件处理函数my$(&quot;btn&quot;).onclick=function () &#123; //判断当前点击的按钮的value属性值 if(this.value==&quot;隐藏&quot;)&#123; my$(&quot;dv&quot;).style.display=&quot;none&quot;;//隐藏 this.value=&quot;显示&quot;; &#125;else if(this.value==&quot;显示&quot;)&#123; my$(&quot;dv&quot;).style.display=&quot;block&quot;;//显示 this.value=&quot;隐藏&quot;; &#125;&#125;; 14.点击按钮设置div的样式 123456789101112131415161718&lt;input type=&quot;button&quot; value=&quot;设置样式&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;style&gt; .cls &#123; width: 300px; height: 200px; background-color: yellow; border: 2px solid red; &#125;&lt;/style&gt;//设置div的样式my$(&quot;btn&quot;).onclick = function () &#123; //在js代码中DOM操作的时候,设置元素的类样式,不用class关键字,应该使用,className //如果有多个样式，中间用空格隔开 my$(&quot;dv&quot;).className=&quot;cls&quot;;&#125;; 15.点击按钮开关灯 123456789101112&lt;input type=&quot;button&quot; value=&quot;开/关灯&quot; id=&quot;btn&quot;/&gt;&lt;style&gt; .cls &#123; background-color: black; &#125;&lt;/style&gt;my$(&quot;btn&quot;).onclick = function () &#123; //获取body标签 document.body.className = document.body.className != &quot;cls&quot; ? &quot;cls&quot; : &quot;&quot;;&#125;; 16案例：隔行变色 12345678910111213141516171819&lt;input type=&quot;button&quot; value=&quot;隔行变色&quot; id=&quot;btn&quot;/&gt;&lt;ul id=&quot;uu&quot;&gt; &lt;li&gt;红旗&lt;/li&gt; &lt;li&gt;五菱宏光&lt;/li&gt; &lt;li&gt;奔驰&lt;/li&gt; &lt;li&gt;兰博基尼&lt;/li&gt; &lt;li&gt;哈弗&lt;/li&gt; &lt;li&gt;奥拓&lt;/li&gt; &lt;li&gt;奥迪&lt;/li&gt; &lt;li&gt;悍马&lt;/li&gt;&lt;/ul&gt;my$(&quot;btn&quot;).onclick = function () &#123; //获取所有的li标签 var list = my$(&quot;uu&quot;).getElementsByTagName(&quot;li&quot;); for (var i = 0; i &lt; list.length; i++) &#123; list[i].style.backgroundColor = i % 2 == 0 ? &quot;red&quot; : &quot;yellow&quot;; &#125;&#125;; 17.根据name属性值获取元素 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;您好&quot; name=&quot;name1&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;您好&quot; name=&quot;name2&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;您好&quot; name=&quot;name1&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;您好&quot; name=&quot;name3&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;您好&quot; name=&quot;name1&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; value=&quot;您好&quot; name=&quot;name1&quot;/&gt;&lt;br/&gt;my$(&quot;btn&quot;).onclick=function () &#123; //通过name属性值获取元素-------表单的标签 var inputs=document.getElementsByName(&quot;name1&quot;); for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].value=&quot;我很好&quot;; &#125;&#125;; 18.根据类样式来获取元素 123456789101112131415161718192021&lt;p&gt;这是一个p&lt;/p&gt;&lt;p class=&quot;cls&quot;&gt;这是另一个p&lt;/p&gt;&lt;span class=&quot;cls&quot;&gt;这是第一个span&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这是第二个span&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cls&quot;&gt;这是第一个div&lt;/div&gt;&lt;div&gt;这是第二个div&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;/&gt;&lt;br/&gt;&lt;script&gt; //点击按钮设置应用cls类样式的标签的背景颜色为红色 //getElementsByClassName();------&gt;h5的，IE9之后支持 my$(&quot;btn&quot;).onclick = function () &#123; //根据类样式的名字来获取元素 var objs = document.getElementsByClassName(&quot;cls&quot;); for (var i = 0; i &lt; objs.length; i++) &#123; //设置每个元素的背景颜色 objs[i].style.backgroundColor = &quot;red&quot;; &#125; &#125;;&lt;/script&gt; 19.querySelector获取元素 1234567891011121314151617put type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;/&gt;&lt;p&gt;这是一个p&lt;/p&gt;&lt;p class=&quot;cls&quot;&gt;这是一个p&lt;/p&gt;&lt;span&gt;这是一个span&lt;/span&gt;&lt;span class=&quot;cls&quot;&gt;这是一个span&lt;/span&gt;var btnObj= document.querySelector(&quot;#btn&quot;);btnObj.onclick=function () &#123; alert(&quot;哈哈,我又变帅了&quot;);&#125;;var objs=document.querySelectorAll(&quot;.cls&quot;);for(var i=0;i&lt;objs.length;i++)&#123; objs[i].style.backgroundColor=&quot;green&quot;;&#125; 4.4 样式操作的注意事项123456789101112131415161718192021222324//obj.style.width = 100; 只能设置行内样式(该样式直接添加在标签体里面)//console.log(obj.style.width) 也只能获取行内样式//如果width的值是写在&lt;style&gt;&lt;/style&gt;表前体里面的，此时通过obj.style.width无法获取obj的宽度//1、获取非行内样式function getStyle(obj,attr)&#123; //获取非行间样式，obj是对象，attr是值 if(obj.currentStyle)&#123; //针对ie获取非行间样式 return obj.currentStyle[attr]; &#125;else&#123; return getComputedStyle(obj,false)[attr]; //针对非ie &#125;;&#125;;//2.封装写法function css(obj,attr,value)&#123; //对象，样式，值。传2个参数的时候为获取样式，3个是设置样式 if(arguments.length == 2)&#123; //arguments参数数组，当参数数组长度为2时表示获取css样式 return getStyle(obj,attr); //返回对象的非行间样式用上面的getStyle函数 &#125;else&#123; if(arguments.length == 3)&#123; //当传三个参数的时候为设置对象的某个值 obj.style[attr] = value; &#125;; &#125;;&#125;; 4.5 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 案例1.点击按钮禁用文本框 12345678&lt;input type=&quot;button&quot; value=&quot;禁用文本框&quot; id=&quot;btn&quot;/&gt;&lt;input type=&quot;text&quot; value=&quot;文本框&quot; id=&quot;txt&quot;/&gt;//先根据id获取按钮,为按钮注册点击事件,添加事件处理函数document.getElementById(&quot;btn&quot;).onclick=function () &#123; //根据id获取文本框,设置disabled属性 document.getElementById(&quot;txt&quot;).disabled=true;&#125;; 案例2：点击按钮选择菜单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;点菜&quot; id=&quot;btn&quot;/&gt;&lt;select name=&quot;&quot; id=&quot;ss&quot;&gt; &lt;option value=&quot;1&quot;&gt;油炸榴莲&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;爆炒臭豆腐&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;清蒸&lt;/option&gt; &lt;option value=&quot;4&quot; id=&quot;op1&quot;&gt;凉拌班主任&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;红烧&lt;/option&gt;&lt;/select&gt;&lt;script&gt; function my$(id) &#123; return document.getElementById(id); &#125; my$(&quot;btn&quot;).onclick=function () &#123; //点击按钮选择菜 my$(&quot;op1&quot;).selected=true; &#125;;&lt;/script&gt;&lt;textarea name=&quot;&quot; id=&quot;tt&quot; cols=&quot;30&quot; rows=&quot;10&quot; readonly=&quot;readonly&quot; &gt; 注册用户的协议: 某人问智者, 大师:您觉得怎么做才是最快乐的? 回答说:不要和愚者辩论 这个人说:我不这么认为! 大师说:您说的对, 我就是这么帅&lt;/textarea&gt;&lt;input type=&quot;button&quot; value=&quot;注册&quot; id=&quot;btn2&quot;/&gt;&lt;script&gt; my$(&quot;btn2&quot;).onclick=function () &#123; //设置textarea也用value，看成表单标签 my$(&quot;tt&quot;).value=&quot;嘎嘎&quot;; //my$(&quot;tt&quot;).innerText=&quot;哈哈&quot;; &#125;;&lt;/script&gt;&lt;/body&gt;//注意点：如果要在下一个script标签中引用其他script标签中的函数，得让其他script标签写在前面 案例3.点击按钮修改性别和兴趣 12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;修改性别&quot; id=&quot;btn1&quot;/&gt;&lt;input type=&quot;radio&quot; value=&quot;1&quot; name=&quot;sex&quot;/&gt;男&lt;input type=&quot;radio&quot; value=&quot;2&quot; name=&quot;sex&quot; id=&quot;rad1&quot;/&gt;女&lt;input type=&quot;radio&quot; value=&quot;3&quot; name=&quot;sex&quot;/&gt;保密&lt;script&gt; //规律:在表单标签中,如果属性和值只有一个,并且值是这个属性本身,那么 //那么,在写js代码,DOM操作的时候,这个属性值,是布尔类型就可以了 my$(&quot;btn1&quot;).onclick = function () &#123; my$(&quot;rad1&quot;).checked = true; &#125;;&lt;/script&gt;&lt;br /&gt;&lt;input type=&quot;button&quot; value=&quot;选择兴趣&quot; id=&quot;btn2&quot;/&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;xingqu&quot; /&gt;吃饭&lt;input type=&quot;checkbox&quot; value=&quot;2&quot; name=&quot;xingqu&quot; /&gt;睡觉&lt;input type=&quot;checkbox&quot; value=&quot;3&quot; name=&quot;xingqu&quot; id=&quot;ck1&quot; /&gt;打豆豆&lt;input type=&quot;checkbox&quot; value=&quot;4&quot; name=&quot;xingqu&quot; /&gt;打篮球&lt;input type=&quot;checkbox&quot; value=&quot;5&quot; name=&quot;xingqu&quot; /&gt;打足球&lt;input type=&quot;checkbox&quot; value=&quot;6&quot; name=&quot;xingqu&quot; id=&quot;ck2&quot; /&gt;打铅球&lt;script&gt; my$(&quot;btn2&quot;).onclick=function () &#123; my$(&quot;ck1&quot;).checked=true; my$(&quot;ck2&quot;).checked=true; &#125;;&lt;/script&gt;&lt;/body&gt;//注意：这里可以将my$的函数封装到common.js中 案例4 : 全选全不选 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; id=&quot;j_cbAll&quot;/&gt; &lt;/th&gt; &lt;th&gt;菜名&lt;/th&gt; &lt;th&gt;饭店&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;j_tb&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;红烧肉&lt;/td&gt; &lt;td&gt;田老师&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;西红柿鸡蛋&lt;/td&gt; &lt;td&gt;田老师&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;油炸榴莲&lt;/td&gt; &lt;td&gt;田老师&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;清蒸助教&lt;/td&gt; &lt;td&gt;田老师&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script&gt; //获取全选的这个复选框 var ckAll = my$(&quot;j_cbAll&quot;); //获取tbody中所有的小复选框 var cks = my$(&quot;j_tb&quot;).getElementsByTagName(&quot;input&quot;); //点击全选的这个复选框,获取他当前的状态,然后设置tbody中所有复选框的状态 ckAll.onclick = function () &#123; //console.log(this.checked); for (var i = 0; i &lt; cks.length; i++) &#123; cks[i].checked = this.checked; &#125; &#125;; //获取tbody中所有的复选框,分别注册点击事件 for(var i=0;i&lt;cks.length;i++)&#123; cks[i].onclick=function () &#123; var flag=true;//默认都被选中了 //判断是否所有的复选框都选中 for(var j=0;j&lt;cks.length;j++)&#123; if(!cks[j].checked)&#123; //没选中就进来了 flag=false; break; &#125; &#125; //全选的这个复选框的状态就是flag这个变量的值 ckAll.checked=flag; &#125;; &#125;&lt;/script&gt; 4.6 自定义属性操作 在html标签中可以添加的自定义属性,通过setAttribute()设置自定义属性值，getAttribute()获取自定义属性值 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 123//元素.属性 和 getAttribute()区别：1.元素.属性可以获取标签封装的dom对象中现有的属性值2.getAttribute()可以获取任意的行内属性(写在标签中的属性) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;ul id=&quot;uu&quot;&gt; &lt;li score=&quot;10&quot;&gt;张三&lt;/li&gt; &lt;li score=&quot;20&quot;&gt;李四&lt;/li&gt; &lt;li score=&quot;30&quot;&gt;王五&lt;/li&gt; &lt;li score=&quot;40&quot;&gt;赵六&lt;/li&gt; &lt;li score=&quot;50&quot;&gt;朱琪&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; //当前的li标签本身没有score这个属性,这个属性是程序员自己添加的。因此在构建此标签的文档对象的时候，标签的score属性不会被封装到dom对象中 //score这个属性是自定义属性，为了存储一些数据 //在html标签中添加的自定义属性,如果想要获取这个属性的值,需要使用getAttribute(&quot;自定义属性的名字&quot;)才能获取这个属性的值 //获取所有的li标签 var list=document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;list.length;i++)&#123; list[i].onclick=function () &#123; //alert(this.score);//不能 //可以 alert(this.getAttribute(&quot;score&quot;)); &#125;; &#125;&lt;/script&gt;&lt;script&gt; //总结:设置自定义属性:setAttribute(&quot;属性的名字&quot;,&quot;属性的值&quot;); //获取自定义属性的值:getAttribute(&quot;属性的名字&quot;) //根据id获取ul标签,并且或者该标签中所有的li var list=my$(&quot;uu&quot;).getElementsByTagName(&quot;li&quot;); //循环遍历 for(var i=0;i&lt;list.length;i++)&#123; //先为每个li添加自定义属性 //list[i].score=(i+1)*10;//此方式,自定义属性在DOM对象上,不在标签中 list[i].setAttribute(&quot;score&quot;,(i+1)*10); //点击每个li标签,显示对应的自定义属性值 list[i].onclick=function()&#123; alert(this.getAttribute(&quot;score&quot;)); &#125;; &#125;&lt;/script&gt;&lt;div id=&quot;dv&quot; score=&quot;10&quot; class=&quot;cls&quot;&gt;&lt;/div&gt;&lt;script&gt; //移除自定义属性:removeAttribute(&quot;属性的名字&quot;) //点击按钮移除元素的自定义属性 my$(&quot;btn&quot;).onclick=function () &#123; //my$(&quot;dv&quot;).removeAttribute(&quot;score&quot;); //还可以通过removeAttribute()移除元素的类样式 //my$(&quot;dv&quot;).className=&quot;&quot;; //值没有了,但是属性还是有的 my$(&quot;dv&quot;).removeAttribute(&quot;class&quot;); //移除元素的自带的属性 &#125;;&lt;/script&gt; 4.7 自定义属性的注意事项1234567891011//1. li.setAttribute(&quot;score&quot;,100);//a.会在li标签上生成一个score属性//b.该属性由于不是html的标准属性，所以不会被封装到dom对象中//c.可以用getAttribute(&quot;score&quot;)方法来获取该属性值，但是由于该属性值不是对象的基本信息，所以无法通过li.score来访问//2. li.score = 100;//a.给li这个dom对象添加一个属性值，该信息会被添加到dom对象中//b.不会在li标签上生成一个score属性//c.可以通过li.score来访问该属性值，但是不可以用getAttribute(&quot;score&quot;)方法来获取该属性值，因为这个属性不在标签上//3.如果要给一个dom对象添加自定义的数据，建议直接使用点的方式，因为使用setAttribute()会在标签上生成额外的属性节点 案例：tab键切换显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;div class=&quot;hd&quot;&gt; &lt;span class=&quot;current&quot;&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;新闻&lt;/span&gt; &lt;span&gt;综合&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;ul&gt; &lt;li class=&quot;current&quot;&gt;我是体育模块&lt;/li&gt; &lt;li&gt;我是娱乐模块&lt;/li&gt; &lt;li&gt;我是新闻模块&lt;/li&gt; &lt;li&gt;我是综合模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style-type: none; &#125; .box &#123; width: 400px; height: 300px; border: 1px solid #ccc; margin: 100px auto; overflow: hidden; &#125; .hd &#123; height: 45px; &#125; .hd span &#123; display: inline-block; width: 90px; background-color: pink; line-height: 45px; text-align: center; cursor: pointer; &#125; .hd span.current &#123; background-color: purple; &#125; .bd li &#123; height: 255px; background-color: purple; display: none; &#125; .bd li.current &#123; display: block; &#125;&lt;/style&gt;&lt;script&gt; //获取最外面的div var box=my$(&quot;box&quot;); //获取的是里面的第一个div var hd=box.getElementsByTagName(&quot;div&quot;)[0]; //获取的是里面的第二个div var bd=box.getElementsByTagName(&quot;div&quot;)[1]; //获取所有的li标签 var list=bd.getElementsByTagName(&quot;li&quot;);//================================= //获取所有的span标签 var spans=hd.getElementsByTagName(&quot;span&quot;); //循环遍历的方式,添加点击事件 for(var i=0;i&lt;spans.length;i++)&#123; //在点击之前就把索引保存在span标签中 spans[i].setAttribute(&quot;index&quot;,i);//================================ spans[i].onclick=function () &#123; //第一件事,所有的span的类样式全部移除 for(var j=0;j&lt;spans.length;j++)&#123; spans[j].removeAttribute(&quot;class&quot;); &#125; //第二件事,当前被点击的span应用类样式 this.className=&quot;current&quot;; //span被点击的时候获取存储的索引值 //alert(this.getAttribute(&quot;index&quot;)); var num=this.getAttribute(&quot;index&quot;);//============================== //获取所有的li标签,每个li标签先全部隐藏 for(var k=0;k&lt;list.length;k++)&#123; list[k].removeAttribute(&quot;class&quot;); &#125; //当前被点击的span对应的li标签显示 list[num].className=&quot;current&quot;; &#125;; &#125;&lt;/script&gt; 5. 常用事件事件：触发-响应机制 5.1 事件的基本使用1234var box = document.getElementById(&#x27;box&#x27;);box.onclick = function() &#123; console.log(&#x27;代码会在box被点击后执行&#x27;); &#125;; 5.2 常用的事件12345mouseenter mouseleave 不会触发事件冒泡mouseover mouseout 会触发事件冒泡onkeydown 事件会在用户按下一个键盘按键时发生，先于onkeypress执行onkeypress 事件不会被所有按键触发（例如 ALT、CTRL、SHIFT、ESC） 5.3 案例1.鼠标移入高亮 12345678910111213141516171819202122232425&lt;ul&gt; &lt;li&gt;金士百&lt;/li&gt; &lt;li&gt;雪花&lt;/li&gt; &lt;li&gt;百威&lt;/li&gt; &lt;li&gt;燕京&lt;/li&gt; &lt;li&gt;青岛&lt;/li&gt; &lt;li&gt;崂山&lt;/li&gt; &lt;li&gt;珠江&lt;/li&gt; &lt;li&gt;华丹&lt;/li&gt;&lt;/ul&gt;//鼠标进入和鼠标离开两个事件//获取所有的li标签var list = document.getElementsByTagName(&quot;li&quot;);for (var i = 0; i &lt; list.length; i++) &#123; //为li注册鼠标进入事件 list[i].onmouseover = function () &#123; this.style.backgroundColor = &quot;yellow&quot;; &#125;; //为li注册鼠标离开事件 list[i].onmouseout = function () &#123; //恢复到这个标签默认的颜色 this.style.backgroundColor = &quot;&quot;; &#125;;&#125; 2.鼠标移入显示隐藏二维码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div class=&quot;nodeSmall&quot; id=&quot;node_small&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;!--锚定--&gt; &lt;div class=&quot;erweima hide&quot; id=&quot;er&quot;&gt; &lt;img src=&quot;images/456.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .nodeSmall &#123; width: 50px; height: 50px; background: url(images/bgs.png) no-repeat -159px -51px; position: fixed; right: 10px; top: 40%; &#125; .erweima &#123; position: absolute; top: 0; left: -150px; &#125; .nodeSmall a &#123; display: block; width: 50px; height: 50px; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125;&lt;/style&gt; &lt;script&gt; //获取鼠标要进入的a标签 //先获取最外面的div var aObj=my$(&quot;node_small&quot;).getElementsByTagName(&quot;a&quot;)[0]; //为a注册鼠标进入 aObj.onmouseover=function () &#123; my$(&quot;er&quot;).className=&quot;erweima show&quot;; &#125;; //为a注册鼠标离开 aObj.onmouseout=function () &#123; my$(&quot;er&quot;).className=&quot;erweima hide&quot;; &#125;;&lt;/script&gt; 3.鼠标移入让div高亮 12345678910111213141516171819202122232425262728293031&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;style&gt; div&#123; width: 200px; height: 150px; background-color: green; float: left; margin-left: 10px; border: 2px solid green; &#125;&lt;/style&gt;&lt;script&gt; //获取所有的div var dvObjs=document.getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;dvObjs.length;i++)&#123; //为每个div添加鼠标进入的事件 dvObjs[i].onmouseover=function () &#123; this.style.border=&quot;2px solid red&quot;; &#125;; //为每个div添加鼠标离开的事件 dvObjs[i].onmouseout=function () &#123; this.style.border=&quot;&quot;; &#125;; &#125;&lt;/script&gt; 4.模拟输入框 123456789101112131415161718192021222324252627&lt;input type=&quot;text&quot; value=&quot;请输入搜索内容&quot; id=&quot;txt&quot;/&gt; &lt;style&gt; input &#123; color: gray; &#125;&lt;/style&gt;&lt;script&gt; //注册获取焦点的事件 my$(&quot;txt&quot;).onfocus = function () &#123; //判断文本框的内容是不是默认的内容 if (this.value == &quot;请输入搜索内容&quot;) &#123; this.value = &quot;&quot;;//清空文本框 this.style.color = &quot;black&quot;; &#125; &#125;; //注册失去焦点的事件 my$(&quot;txt&quot;).onblur = function () &#123; if (this.value.length == 0) &#123; this.value = &quot;请输入搜索内容&quot;; this.style.color = &quot;gray&quot;; &#125; &#125;;&lt;/script&gt; 5.判断密码长度 12345678910111213&lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;txt&quot;/&gt;&lt;script&gt; //获取文本框 my$(&quot;txt&quot;).onblur=function () &#123; //判断密码的长度 if(this.value.length&gt;=6&amp;&amp;this.value.length&lt;=10)&#123; this.style.backgroundColor=&quot;red&quot;; &#125;else&#123; this.style.backgroundColor=&quot;green&quot;; &#125; &#125;;&lt;/script&gt; 6. 节点操作EventTarget是一个由可以接收事件的对象实现的接口,并且可以为它们创建侦听器 6.1 节点介绍1234567891011121314151617181920节点(Node)的分类：文档节点 Document元素节点 Element 指的是页面中的标签属性节点 Attr文本节点 Text节点的属性：nodeType ： 1--&gt;标签，2--&gt;属性,3--&gt;文本nodeName ： 标签--&gt;标签名，属性--&gt;属性名，文本--&gt;#textnodeValue : 标签--&gt;null，属性--&gt;属性值，文本--&gt;文本内容节点层次的属性 parentNode ---父节点 parentElement ---父元素(结果和parentNode一样) childNodes ---所有子节点，包含文本节点 children -- 所有子元素 nextSibling/previousSibling --前一个子节点(包含文本节点),IE8中获取第一个子元素 nextElementSibling/previousElementSibling --前一个子元素，IE8中不支持 firstChild/lastChild --获取第一个子节点，IE8中是第一个子元素 firstElementChild --获取第一个子元素，IE8中不支持 6.2 节点案例案例1：获取相关节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;div id=&quot;dv&quot;&gt; &lt;span&gt;这是div中的第一个span标签&lt;/span&gt; &lt;p&gt;这是div中的第二个元素,第一个p标签&lt;/p&gt; &lt;ul id=&quot;uu&quot;&gt; &lt;li&gt;乔峰&lt;/li&gt; &lt;li&gt;鹿茸&lt;/li&gt; &lt;li id=&quot;three&quot;&gt;段誉&lt;/li&gt; &lt;li&gt;卡卡西&lt;/li&gt; &lt;li&gt;雏田&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;//1---------------------------------------------------------------------------------&lt;script&gt; var dvObj=document.getElementById(&quot;dv&quot;); //获取里面的每个子节点 for(var i=0;i&lt;dvObj.childNodes.length;i++)&#123; var node=dvObj.childNodes[i]; //nodeType---&gt;节点的类型:1---标签,2---属性,3---文本 //nodeName---&gt;节点的名字:大写的标签--标签,小写的属性名---属性,#text---文本 //nodeValue--&gt;节点的值:标签---null,属性--属性的值,文本--文本内容 console.log(node.nodeType+&quot;=====&quot;+node.nodeName+&quot;====&quot;+node.nodeValue); &#125; var dvObj=document.getElementById(&quot;dv&quot;); //获取的是属性的节点 var node=dvObj.getAttributeNode(&quot;id&quot;); console.log(node.nodeType+&quot;----&quot;+node.nodeName+&quot;====&quot;+node.nodeValue); var dvObj=document.getElementById(&quot;dv&quot;); //子节点 console.log(dvObj.childNodes);//7个子节点 //子元素 console.log(dvObj.children);&lt;/script&gt;//2---------------------------------------------------------------------------------&lt;script&gt; var ulObj=my$(&quot;uu&quot;); console.log(ulObj.parentNode);//div console.log(ulObj.parentNode.parentNode);//body console.log(ulObj.parentNode.parentNode.parentNode);//html console.log(ulObj.parentNode.parentNode.parentNode.parentNode);//document console.log(ulObj.parentNode.parentNode.parentNode.parentNode.parentNode);//null //ul标签的父级节点 console.log(ulObj.parentNode); //ul标签的父级元素,结果和父节点一样 console.log(ulObj.parentElement); console.log(ulObj.parentNode.nodeType);//标签的---1 console.log(ulObj.parentNode.nodeName);//标签---大写的标签名字 console.log(ulObj.parentNode.nodeValue);//标签---null&lt;/script&gt;//3---------------------------------------------------------------------------------&lt;script&gt; //获取节点和元素的 //ul var ulObj=document.getElementById(&quot;uu&quot;); //父级节点 console.log(ulObj.parentNode); //父级元素 console.log(ulObj.parentElement); //子节点 console.log(ulObj.childNodes); //子元素 console.log(ulObj.children); //第一个子节点 console.log(ulObj.firstChild);//------------------------IE8中是第一个子元素 //第一个子元素 console.log(ulObj.firstElementChild);//-----------------IE8中不支持 //最后一个子节点 console.log(ulObj.lastChild);//------------------------IE8中是第一个子元素 //最后一个子元素 console.log(ulObj.lastElementChild);//-----------------IE8中不支持 //某个元素的前一个兄弟节点 console.log(my$(&quot;three&quot;).previousSibling);//------------------------IE8中是前面一个子元素 //某个元素的前一个兄弟元素 console.log(my$(&quot;three&quot;).previousElementSibling);//-----------------IE8中不支持 //某个元素的后一个兄弟节点 console.log(my$(&quot;three&quot;).nextSibling);//------------------------IE8中是后面一个子元素 //某个元素的后一个兄弟元素 console.log(my$(&quot;three&quot;).nextElementSibling);//-----------------IE8中不支持&lt;/script&gt; //总结:凡是获取节点的代码在谷歌和火狐得到的都是 相关的节点 //凡是获取元素的代码在谷歌和火狐得到的都是 相关的元素 //从子节点和兄弟节点开始,凡是获取节点的代码在IE8中得到的是元素,获取元素的相关代码,在IE8中得到的是undefined----元素的代码,iE中不支持 案例2：点击按钮设置p标签背景色 1234567891011121314151617181920212223242526272829&lt;input type=&quot;button&quot; value=&quot;变色&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt; &lt;span&gt;这是span&lt;/span&gt; &lt;p&gt;这是p&lt;/p&gt; &lt;span&gt;这是span&lt;/span&gt; &lt;p&gt;这是p&lt;/p&gt; &lt;span&gt;这是span&lt;/span&gt; &lt;p&gt;这是p&lt;/p&gt; &lt;span&gt;这是span&lt;/span&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/div&gt;&lt;script&gt; my$(&quot;btn&quot;).onclick = function () &#123; //先获取div var dvObj = my$(&quot;dv&quot;); //获取里面所有的子节点 var nodes = dvObj.childNodes; //循环遍历所有的子节点 for (var i = 0; i &lt; nodes.length; i++) &#123; //判断这个子节点是不是p标签 if (nodes[i].nodeType == 1 &amp;&amp; nodes[i].nodeName == &quot;P&quot;) &#123; nodes[i].style.backgroundColor = &quot;red&quot;; &#125; &#125; &#125;; //点击按钮,设置p变色---节点的方式做&lt;/script&gt; 案例3：点击按钮隔行变色 12345678910111213141516171819202122232425262728&lt;input type=&quot;button&quot; value=&quot;变色&quot; id=&quot;btn&quot;/&gt;&lt;ul id=&quot;uu&quot;&gt; &lt;li&gt;AA&lt;/li&gt; &lt;li&gt;BB&lt;/li&gt; &lt;li&gt;CC&lt;/li&gt; &lt;li&gt;DD&lt;/li&gt; &lt;li&gt;EE&lt;/li&gt; &lt;li&gt;FF&lt;/li&gt; &lt;li&gt;GG&lt;/li&gt; &lt;li&gt;HH&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; //隔行变色--li my$(&quot;btn&quot;).onclick = function () &#123; var count=0;//记录有多少个li //获取ul中所有的子节点 var nodes = my$(&quot;uu&quot;).childNodes; //for循环里面不可以直接用i，因为nodes里面包含了文本节点，不光是li标签 for (var i = 0; i &lt; nodes.length; i++) &#123; //判断这个节点是不是li标签 if (nodes[i].nodeType == 1 &amp;&amp; nodes[i].nodeName == &quot;LI&quot;) &#123; nodes[i].style.backgroundColor=count%2==0?&quot;red&quot;:&quot;yellow&quot;; count++;//8个 &#125; &#125; &#125;;&lt;/script&gt; 案例4：切换背景图片 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body id=&quot;bd&quot;&gt; &lt;div id=&quot;mask&quot;&gt; &lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var imgObjs=my$(&quot;mask&quot;).children;//获取的所有的子元素 //循环遍历所有img,注册点击事件 for(var i=0;i&lt;imgObjs.length;i++)&#123; console.log(&quot;xx&quot;); imgObjs[i].onclick=function () &#123; document.body.style.backgroundImage=&quot;url(&quot;+this.src+&quot;)&quot;; &#125;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; body &#123; background-image: url(&quot;images/1.jpg&quot;); &#125; #mask &#123; background-color: rgba(255, 255, 255, 0.3); height: 200px; text-align: center; &#125; #mask img &#123; width: 200px; margin-top: 35px; cursor: pointer; &#125;&lt;/style&gt; 6.3 获取节点的代码封装123456789101112131415161718192021222324252627282930//element.firstChild---&gt;谷歌和火狐获取的是第一个子节点//element.firstChild---&gt;IE8获取的是第一个子元素//element.firstElementChild------&gt;谷歌和火狐是第一个子元素,IE8不支持//获取任意一个父级元素的第一个子级元素function getFirstElementChild(element) &#123; if(element.firstElementChild)&#123;//true---&gt;支持 return element.firstElementChild; &#125;else&#123; var node=element.firstChild;//第一个节点 while (node&amp;&amp;node.nodeType!=1)&#123; node=node.nextSibling; &#125; return node; &#125;&#125;//获取任意一个父级元素的最后一个子级元素function getLastElementChild(element) &#123; if(element.lastElementChild)&#123;//true---&gt;支持 return element.lastElementChild; &#125;else&#123; var node=element.lastChild;//第一个节点 while (node&amp;&amp;node.nodeType!=1)&#123; node=node.previousSibling; &#125; return node; &#125;&#125;console.log(getFirstElementChild(my$(&quot;uu&quot;)).innerText);console.log(getLastElementChild(my$(&quot;uu&quot;)).innerText); 6.4 节点操作的方法12345节点操作的方法 appendChild() insertBefore() removeChild() replaceChild() 123456789101112131415161718192021222324252627282930313233343536&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;干掉第一个子元素&quot; id=&quot;btn2&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;干掉所有子元素&quot; id=&quot;btn3&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script&gt; var i=0; my$(&quot;btn&quot;).onclick=function () &#123; i++; var obj= document.createElement(&quot;input&quot;); obj.type=&quot;button&quot;; obj.value=&quot;按钮&quot;+i; //my$(&quot;dv&quot;).appendChild(obj);//追加子元素 //把新的子元素插入到my$(&quot;dv&quot;)第一个子元素的前面 my$(&quot;dv&quot;).insertBefore(obj,my$(&quot;dv&quot;).firstElementChild); //用obj2替换掉my$(&quot;dv&quot;)中的obj var obj2= document.createElement(&quot;input&quot;); obj2.type=&quot;button&quot;; obj2.value=&quot;按钮&quot;+2; my$(&quot;dv&quot;).replaceChild(obj2,obj);// &#125;; my$(&quot;btn2&quot;).onclick=function () &#123; //移除父级元素中第一个子级元素 my$(&quot;dv&quot;).removeChild(my$(&quot;dv&quot;).firstElementChild); &#125;; my$(&quot;btn3&quot;).onclick=function () &#123; //点击按钮删除div中所有的子级元素 //判断父级元素中有没有第一个子元素 while(my$(&quot;dv&quot;).firstElementChild)&#123; my$(&quot;dv&quot;).removeChild(my$(&quot;dv&quot;).firstElementChild); &#125; &#125;;&lt;/script&gt; 7. 创建元素的三种方式7.1 document.write()12document.write(&#x27;新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;&#x27;);//document.write()创建元素,缺陷:如果是在页面加载完毕后,此时通过这种方式创建元素,那么页面上存在的所有的内容全部被干掉 7.2 innerHTML123456789//给box追加文本内容var box = document.getElementById(&#x27;box&#x27;);box.innerHTML = &#x27;新内容&lt;p&gt;新标签&lt;/p&gt;&#x27;;//点击按钮,在div中创建一个图片my$(&quot;btn&quot;).onclick=function () &#123; my$(&quot;dv&quot;).innerHTML=&quot;&lt;img src=&#x27;images/liuyan.jpg&#x27; alt=&#x27;美女&#x27; /&gt;&quot;;&#125;; 案例：点击按钮创建列表 123456789101112131415161718192021222324var names = [&quot;杨过&quot;, &quot;郭靖&quot;, &quot;张无忌&quot;, &quot;张三丰&quot;, &quot;乔峰&quot;, &quot;段飞&quot;, &quot;丁棚&quot;];my$(&quot;btn&quot;).onclick = function () &#123; var str = &quot;&lt;ul style=&#x27;list-style-type: none; cursor: pointer&#x27;&gt;&quot;; //根据循环创建对应对数的li for (var i = 0; i &lt; names.length; i++) &#123; str += &quot;&lt;li&gt;&quot; + names[i] + &quot;&lt;/li&gt;&quot;; &#125; str += &quot;&lt;/ul&gt;&quot;; my$(&quot;dv&quot;).innerHTML = str; //代码执行到这里,li已经有了 //获取所有的li,遍历,添加鼠标进入事件,鼠标离开事件 var list = my$(&quot;dv&quot;).getElementsByTagName(&quot;li&quot;); for (var i = 0; i &lt; list.length; i++) &#123; //鼠标进入 list[i].onmouseover = function () &#123; this.style.backgroundColor = &quot;yellow&quot;; &#125;; //鼠标离开 list[i].onmouseout = function () &#123; this.style.backgroundColor = &quot;&quot;; &#125;; &#125;&#125;; 案例.二级联动 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;select id=&quot;city&quot;&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;tj&quot;&gt;天津&lt;/option&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;area&quot;&gt; &lt;option value=&quot;hd&quot;&gt;海淀&lt;/option&gt; &lt;option value=&quot;cy&quot;&gt;朝阳&lt;/option&gt; &lt;option value=&quot;dc&quot;&gt;东城&lt;/option&gt; &lt;/select&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var selectCity = document.getElementById(&quot;city&quot;); var selectArea = document.getElementById(&quot;area&quot;); selectCity.onchange=function()&#123; var optionVal = selectCity.value; if(optionVal==&quot;bj&quot;)&#123; selectArea.innerHTML = &quot;&lt;option value=&#x27;hd&#x27;&gt;海淀&lt;/option&gt;&lt;option value=&#x27;cy&#x27;&gt;朝阳&lt;/option&gt;&lt;option value=&#x27;dc&#x27;&gt;东城&lt;/option&gt;&quot;; &#125; else if(optionVal==&quot;tj&quot;)&#123; selectArea.innerHTML = &quot;&lt;option value=&#x27;hk&#x27;&gt;南开&lt;/option&gt;&lt;option value=&#x27;hx&#x27;&gt;河西&lt;/option&gt;&lt;option value=&#x27;hd&#x27;&gt;河东&lt;/option&gt;&quot;; &#125; else&#123; selectArea.innerHTML = &quot;&lt;option value=&#x27;pd&#x27;&gt;浦东&lt;/option&gt;&lt;option value=&#x27;yp&#x27;&gt;杨浦&lt;/option&gt;&lt;option value=&#x27;px&#x27;&gt;浦西&lt;/option&gt;&quot;; &#125; &#125;; &lt;/script&gt; 7.3 document.createElement()1234567my$(&quot;btn&quot;).onclick = function () &#123; //创建元素的 var pObj = document.createElement(&quot;p&quot;); setInnnerText(pObj, &quot;这是一个p&quot;); //把创建后的子元素追加到父级元素中 my$(&quot;dv&quot;).appendChild(pObj);&#125;; 7.3.1 使用document.createElement()循环插入元素12345678910111213141516//同一元素无法重复插入window.onload = function()&#123; var el = document.createElement(&#x27;div&#x27;); el.appendChild(document.createTextNode(&#x27;Hi&#x27;)); for (var i = 10; i &gt; 0; --i) document.body.appendChild(el);&#125;; //正确的 同时注意不要设置插入多次的元素的id,否则造成错误window.onload = function()&#123; var el = document.createElement(&#x27;div&#x27;); el.appendChild(document.createTextNode(&#x27;Hi&#x27;)); for (var i = 10; i &gt; 0; --i) document.body.appendChild(el.cloneNode(true));&#125;; 7.3.2 document.createDocumentFragment()的使用上述方法，虽然能够成功生成相同的dom元素，但是性能上是存在问题的。 每次插入dom元素到body后，dom树会重排，之后页面会因为新的dom元素的插入而重新绘制，这两个过程是极其耗时的。 因此，推荐使用文档碎片document.createDocumentFragment()。 https://www.cnblogs.com/zhangkeyu/p/6665793.html 12345678910//利用文档碎片 提高性能 frag相当于一个容器 frag并不会插入body而是把frag的内部元素全部插入bodywindow.onload = function()&#123; var frag = document.createDocumentFragment(); var el = document.createElement(&#x27;div&#x27;); el.appendChild(document.createTextNode(&#x27;Hi&#x27;)); for (var i = 10; i &gt; 0; --i) frag.appendChild(el.cloneNode(true)); //先将生成的dom全部插入frag先，这个过程并不会触发重排与重绘 &#125;; document.body.appendChild(frag); //将生成的frag插入body中，将10此重排重绘的过程压缩为一次&#125;; 7.3.3 案例 动态创建列表，高亮显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;input type=&quot;button&quot; value=&quot;创建列表&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style-type: none; cursor: pointer; &#125; div &#123; width: 200px; height: 400px; border: 2px solid red; &#125;&lt;/style&gt;&lt;script&gt; var kungfu = [&quot;降龙十八掌&quot;, &quot;黯然销魂掌&quot;, &quot;葵花宝典&quot;, &quot;九阴真经&quot;, &quot;吸星大法&quot;, &quot;如来神掌&quot;, &quot;化骨绵掌&quot;, &quot;玉女心经&quot;, &quot;极乐神功&quot;, &quot;辟邪剑谱&quot;]; //点击按钮动态的创建列表,把列表加到div中 my$(&quot;btn&quot;).onclick = function () &#123; //创建ul,把ul立刻加入到父级元素div中 var ulObj = document.createElement(&quot;ul&quot;); my$(&quot;dv&quot;).appendChild(ulObj); //动态的创建li,加到ul中 for (var i = 0; i &lt; kungfu.length; i++) &#123; var liObj = document.createElement(&quot;li&quot;); //设置li中间的文字内容 liObj.innerHTML = kungfu[i]; ulObj.appendChild(liObj); //为li添加鼠标进入事件 liObj.onmouseover = mouseoverHandle; //为li添加鼠标离开事件 liObj.onmouseout = mouseoutHandle; &#125; &#125;; //此位置.按钮的点击事件的外面 function mouseoverHandle() &#123; this.style.backgroundColor = &quot;red&quot;; &#125; function mouseoutHandle() &#123; this.style.backgroundColor = &quot;&quot;; &#125; //如果是循环的方式添加事件,推荐用命名函数,因为可以保证循环中使用的都是同一个函数 //如果不是循环的方式添加事件,推荐使用匿名函数。my$(&quot;btn&quot;).onclick = function()&#123;&#125; &lt;/script&gt; 根据数据动态创建表格 12345678910111213141516171819202122232425262728293031323334353637&lt;input type=&quot;button&quot; value=&quot;创建表格&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script&gt; var arr=[ &#123;name:&quot;百度&quot;,href:&quot;http://www.baidu.com&quot;&#125;, &#123;name:&quot;谷歌&quot;,href:&quot;http://www.google.com&quot;&#125;, &#123;name:&quot;优酷&quot;,href:&quot;http://www.youku.com&quot;&#125;, &#123;name:&quot;土豆&quot;,href:&quot;http://www.tudou.com&quot;&#125;, &#123;name:&quot;快播&quot;,href:&quot;http://www.kuaibo.com&quot;&#125;, &#123;name:&quot;爱奇艺&quot;,href:&quot;http://www.aiqiyi.com&quot;&#125; ]; //点击按钮创建表格 my$(&quot;btn&quot;).onclick=function () &#123; //创建table加入到div中 var tableObj=document.createElement(&quot;table&quot;); tableObj.border=&quot;1&quot;; tableObj.cellPadding=&quot;0&quot;; tableObj.cellSpacing=&quot;0&quot;; my$(&quot;dv&quot;).appendChild(tableObj); //创建行,把行加入到table中 for(var i=0;i&lt;arr.length;i++)&#123; var dt=arr[i];//每个对象 var trObj=document.createElement(&quot;tr&quot;); tableObj.appendChild(trObj); //创建第一个列,然后加入到行中 var td1=document.createElement(&quot;td&quot;); td1.innerText=dt.name; trObj.appendChild(td1); //创建第二个列 var td2=document.createElement(&quot;td&quot;); td2.innerHTML=&quot;&lt;a href=&quot;+dt.href+&quot;&gt;&quot;+dt.name+&quot;&lt;/a&gt;&quot;; trObj.appendChild(td2); &#125; &#125;;&lt;/script&gt; 模拟百度搜索框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索&quot; id=&quot;btn&quot;&gt;&lt;/div&gt;&lt;style&gt; #box &#123; width: 450px; margin: 200px auto; &#125; #txt &#123; width: 350px; &#125;&lt;/style&gt;&lt;script&gt; var keyWords = [&quot;我是最纯洁的&quot;, &quot;我是最帅的&quot;, &quot;小段是最猥琐的&quot;, &quot;小超是最龌龊的&quot;, &quot;他说妹妹很乖&quot;, &quot;传说在有个很帅很纯洁的张飞&quot;, &quot;苹果好吃&quot;, &quot;苹果此次召回还是没有中国&quot;]; //获取文本框注册键盘抬起事件 my$(&quot;txt&quot;).onkeyup = function () &#123; //每一次的键盘抬起都判断页面中有没有这个div if(my$(&quot;dv&quot;))&#123; //删除一次 my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;)); &#125; //获取文本框输入的内容 var text = this.value; //临时数组--空数组-------&gt;存放对应上的数据 var tempArr = []; //把文本框输入的内容和数组中的每个数据对比 for (var i = 0; i &lt; keyWords.length; i++) &#123; //是否是最开始出现的 if (keyWords[i].indexOf(text) == 0) &#123; tempArr.push(keyWords[i]);//追加 &#125; &#125; //如果文本框是空的,临时数组是空的,不用创建div if (this.value.length == 0 || tempArr.length == 0) &#123; return; &#125; //创建div,把div加入id为box的div中 var dvObj = document.createElement(&quot;div&quot;); my$(&quot;box&quot;).appendChild(dvObj); dvObj.id = &quot;dv&quot;; dvObj.style.width = &quot;350px&quot;; //dvObj.style.height=&quot;100px&quot;;//肯定是不需要的------ dvObj.style.border = &quot;1px solid green&quot;; //循环遍历临时数组,创建对应的p标签 for (var i = 0; i &lt; tempArr.length; i++) &#123; //创建p标签 var pObj = document.createElement(&quot;p&quot;); //把p加到div中 dvObj.appendChild(pObj); setInnerText(pObj, tempArr[i]); pObj.style.margin = 0; pObj.style.padding = 0; pObj.style.cursor = &quot;pointer&quot;; pObj.style.marginTop = &quot;5px&quot;; pObj.style.marginLeft = &quot;5px&quot;; //鼠标进入 pObj.onmouseover = mouseoverHandle; //鼠标离开 pObj.onmouseout = mouseoutHandle; &#125; &#125;; //此位置.按钮的点击事件的外面 function mouseoverHandle() &#123; this.style.backgroundColor = &quot;yellow&quot;; &#125; function mouseoutHandle() &#123; this.style.backgroundColor = &quot;&quot;; &#125;&lt;/script&gt; 7.4 innerHTML和createElement()的比较就innerHTML这种采用字符串拼接生成dom的方式更加方便，并且效率更高。 但是那原生的createElement又有什么优势呢？ 1.createElement，当元素插入后仍然保留对dom元素的指针。而innerHTML插入后，并没有对dom元素的指针，你需要再通过getElementById重新选取。 2.createElement能够获得事件处理函数，而innerHTML生成的新dom无法获得原先设置的事件处理函数。 1234567891011&lt;script&gt; //1.设置div的innerHTML var str = &quot;&lt;div id=&#x27;inner&#x27; style=&#x27;width:100px;height:100px;background-color: red&#x27;&gt;&lt;/div&gt;&quot;; my$(&quot;dv&quot;).innerHTML = str; //2.绑定事件 my$(&quot;inner&quot;).onclick = function()&#123; console.log(&quot;有&quot;); &#125; //3.重新设置之后，发现之前绑定的事件没了 my$(&quot;dv&quot;).innerHTML = str; &lt;/script&gt; 3.某些情况下，createElement更加快速。比如如果你需要反复操作字符串，在每次处理后再次插入。每次插入都将进行解析与制作dom，在性能上会很差。 1234567//下面代码性能很差，因为字符串的拼接耗时var staDate = new Date(); for(var i=0;i&lt;100;i++)&#123; var str=&quot;&lt;div id=&#x27;div_&#x27;&quot;+i+&quot;&#x27; style=&#x27;width:100px; height:20px;background-color:#eee&#x27;&gt;test&lt;/div&gt;&quot;; my$(&quot;dv&quot;).innerHTML += str; &#125; alert(new Date - staDate); //18 1234567891011121314//当有大量字符串拼接的时候createElement效率更高var staDate = new Date(); var doc = window.document; for(var i=0;i&lt;100;i++)&#123; var oDiv = doc.createElement(&quot;div&quot;); var oText = doc.createTextNode(&quot;text&quot;); oDiv.appendChild(oText); my$(&quot;dv&quot;).appendChild(oDiv); oDiv.style.id = &quot;div_&quot;+i; oDiv.style.width = &quot;100px&quot;; oDiv.style.height = &quot;20px&quot;; oDiv.style.backgroundColor = &quot;#eee&quot;; &#125;alert(new Date - staDate); //2 1234567891011121314151617181920212223242526272829//测试2 ： createElement效率&lt;script&gt; var staDate = new Date(); var d = new Date(); for (var n = 0; n &lt; 1000; n ++) &#123; var e = document.createElement(&#x27;a&#x27;); e.href = &#x27;&#x27;; e.innerText = &#x27;测试&#x27; + n; my$(&quot;dv&quot;).appendChild(e); &#125; alert(new Date - staDate);&lt;/script&gt;//测试2 ： innerHTML效率，使用数组的方式避免字符串的大量拼接&lt;script&gt; var staDate = new Date(); var buf = []; for (var n = 0; n &lt; 1000; n ++) &#123; buf.push(&#x27;&lt;a href=&quot;&quot;&gt;测试&#x27;); buf.push(n); buf.push(&#x27;&lt;/a&gt;&#x27;); &#125; my$(&quot;dv&quot;).innerHTML = buf.join(&#x27;&#x27;); alert(new Date - staDate);&lt;/script&gt;//此时可以发现两种方式的性能差距不是特别大 4.可读性与可维护上createElement会优秀一些 8. 事件详解8.1 注册&#x2F;移除事件的三种方式1234567891011var box = document.getElementById(&#x27;box&#x27;);box.onclick = function () &#123; console.log(&#x27;点击后执行&#x27;);&#125;;box.onclick = null;//使用onclick缺点：只能有一个事件//为元素绑定事件对象.addEventListener(&quot;事件类型&quot;,事件处理函数,false); //谷歌和火狐支持,IE8不支持对象.attachEvent(&quot;有on的事件类型&quot;,事件处理函数); //谷歌不支持,火狐不支持,IE8支持 12345678910111213141516171819202122232425262728293031//为按钮绑定点击事件 addEventListener//参数1:事件的类型---事件的名字,没有on//参数2:事件处理函数---函数(命名函数,匿名函数)//参数3:布尔类型,目前就写false(表示事件的阶段)//为同一个元素绑定多个相同的事件--my$(&quot;btn&quot;).addEventListener(&quot;click&quot;,function () &#123; console.log(&quot;猥琐啊&quot;);&#125;,false);my$(&quot;btn&quot;).addEventListener(&quot;click&quot;,function () &#123; console.log(&quot;龌龊啊&quot;);&#125;,false);my$(&quot;btn&quot;).addEventListener(&quot;click&quot;,function () &#123; console.log(&quot;邪恶啊&quot;);&#125;,false);my$(&quot;btn&quot;).addEventListener(&quot;click&quot;,function () &#123; console.log(&quot;下流啊&quot;);&#125;,false);//参数1:事件类型---事件名字，有on attachEvent//参数2:事件处理函数---函数(命名函数,匿名函数)my$(&quot;btn&quot;).attachEvent(&quot;onclick&quot;,function () &#123; console.log(&quot;好帅哦1&quot;);&#125;);my$(&quot;btn&quot;).attachEvent(&quot;onclick&quot;,function () &#123; console.log(&quot;好帅哦2&quot;);&#125;);my$(&quot;btn&quot;).attachEvent(&quot;onclick&quot;,function () &#123; console.log(&quot;好帅哦3&quot;);&#125;); 8.2 绑定事件的兼容代码12345678910111213141516171819202122232425262728293031//绑定事件function addEventListener(element, type, fn) &#123; //火狐 谷歌 if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; //IE else if (element.attachEvent)&#123; element.attachEvent(&#x27;on&#x27; + type,fn); &#125; //正常情况 else &#123; element[&#x27;on&#x27;+type] = fn; &#125;&#125;//解绑事件function removeEventListener(element, type, fn) &#123; //火狐 谷歌 if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; //IE else if (element.detachEvent) &#123; element.detachEvent(&#x27;on&#x27; + type, fn); &#125; //正常情况 else &#123; element[&#x27;on&#x27;+type] = null; &#125;&#125; 8.3 addEventListener和attachEvent区别1234567891011//相同点: 都可以为元素绑定事件//不同点:* 1.方法名不一样* 2.参数个数不一样addEventListener三个参数,attachEvent两个参数* 3.addEventListener 谷歌,火狐,IE11支持,IE8不支持* attachEvent 谷歌火狐不支持,IE11不支持,IE8支持* 4.this不同,addEventListener 中的this是当前绑定事件的对象* attachEvent中的this是window。(IE8中其实通过apply、call改变了this的指向)* 5.addEventListener中事件的类型(事件的名字)没有on* attachEvent中的事件的类型(事件的名字)有on 8.4 事件对象Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。 每一个事件的生成都有一个event对象，这个对象中包含该事件的类型、触发者、触发位置等信息 event.type 获取事件类型 event.target || event.srcElement 用于获取触发事件的元素 clientX&#x2F;clientY 所有浏览器都支持，可视区位置 pageX&#x2F;pageY IE8以前不支持，页面位置 event.preventDefault() 取消默认行为 event.stopPropagation() 阻止事件传播 获取键盘按键信息 8.4.1 事件三要素 事件源 : 触发(被)事件的元素 事件类型 : 事件的触发方式(例如鼠标点击或键盘点击) 事件处理程序 : 事件触发后要执行的代码(函数形式) 8.4.2 event对象的获取1234567//事件参数e在IE8的浏览器中是不存在,此时用window.event来代替//兼容性写法：function f1(e)&#123; var event = e||window.event; console.log(event.target);&#125; 8.4.3 event.type的使用12345678910111213141516171819&lt;input type=&quot;button&quot; value=&quot;呵呵&quot; id=&quot;btn&quot;/&gt;my$(&quot;btn&quot;).onclick = f1;my$(&quot;btn&quot;).onmouseover = f1;my$(&quot;btn&quot;).onmouseout = f1;function f1(e) &#123; switch (e.type) &#123; case &quot;click&quot;: alert(&quot;好帅哦&quot;); break; case &quot;mouseover&quot;: this.style.backgroundColor = &quot;red&quot;; break; case &quot;mouseout&quot;: this.style.backgroundColor = &quot;green&quot;; break; &#125;&#125; 8.4.4 keyCode的使用案例1：ctrl+回车发布留言 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload=function ()&#123; var oTxt1=document.getElementById(&#x27;txt1&#x27;); var oTxt2=document.getElementById(&#x27;txt2&#x27;); oTxt1.onkeydown=function (ev) &#123; var oEvent=ev||event; // ctrlKey表示ctrl键，shiftKey表示shift键 if(oEvent.keyCode==13 &amp;&amp; oEvent.ctrlKey) &#123; oTxt2.value+=oTxt1.value+&#x27;\\n&#x27;; oTxt1.value=&#x27;&#x27;; &#125; &#125;;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input id=&quot;txt1&quot; type=&quot;text&quot; /&gt;&lt;br&gt;&lt;textarea id=&quot;txt2&quot; rows=&quot;10&quot; cols=&quot;40&quot;&gt;&lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt; 案例2：只能输入数字的文本框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt; var txt1 = my$(&quot;txt1&quot;); //键盘按下，此时通过this.value获取的内容仍然是之前的内容 //onkeydown先于oninput执行 //onkeydown方法执行的时候不能获取到最新的value信息 txt1.onkeydown = function(e)&#123; var event = e||window.event; //条件是只能输入数字 48 ~ 57 之间 //0 --&gt;48 //会推荐是 8 //只能输入数字 ： 只要输入的东西不是退格键 以及 &lt;48 &gt;57 我们都认为不可以输入 ,返回 false if(event.keyCode != 8 &amp;&amp; (event.keyCode &lt; 48 || event.keyCode &gt; 57))&#123; //当返回false不会更新input的value值 return false; &#125; else&#123; //当返回true会更新input的value值 return true; &#125; &#125; //是否是中文输入法 var cpLock = false; //中文输入法开始 document.addEventListener(&#x27;compositionstart&#x27;, function(e) &#123; cpLock = true; &#125;); //中文输入法结束(空格或者回车键) document.addEventListener(&#x27;compositionend&#x27;, function(e) &#123; cpLock = false; &#125;) //oninput后与onkeydown执行，可以获取到input最新的value信息 txt1.oninput = function()&#123; if(cpLock)&#123; //把this.value中所有出现的A-Z/a-z都换成空字符串 this.value = this.value.replace(/[A-Za-z]/g,&quot;&quot;); &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;txt1&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 8.4.5 clientX和clientY123456//clientX和clientY代表可视区的位置document.onclick = function(ev)&#123; //兼容的写法 var oev = ev||event; alert(oev.clientX+&quot;,&quot;+oev.clientY);&#125; 8.4.6 PageX和PageY123456789101112131415161718192021222324252627//PageX和PageY : 页面的位置，包含滚动出去的页面&lt;style&gt; body &#123; margin: 0; height: 1000px; &#125; #box &#123; margin: 100px; margin-top: 500px; width: 200px; height: 200px; background-color: red; &#125;&lt;/style&gt;var box = document.getElementById(&#x27;box&#x27;); box.onclick = function (e) &#123; e = e || window.event; // 获取的鼠标在浏览器的可视区域的坐标 // console.log(e.clientX); // console.log(e.clientY); // 鼠标在当前页面的位置 console.log(e.pageX); console.log(e.pageY);&#125; 案例：让img跟随鼠标移动 123456789101112131415161718192021&lt;img src=&quot;images/tianshi.gif&quot; id=&quot;ts&quot; alt=&quot;&quot;&gt;&lt;style&gt; body &#123; height: 1000px; &#125; #ts &#123; position: absolute; &#125;&lt;/style&gt;&lt;script&gt; var ts = document.getElementById(&#x27;ts&#x27;); document.onmousemove = function (e) &#123; e = e || window.event; // ts.style.left = e.clientX - 10 + &#x27;px&#x27;; // ts.style.top = e.clientY - 10 + &#x27;px&#x27;; ts.style.left = e.pageX - 10 + &#x27;px&#x27;; ts.style.top = e.pageY - 10 + &#x27;px&#x27;; &#125;&lt;/script&gt; 8.4.7 PageX和PageY的兼容性处理12345678910111213141516171819202122232425262728293031323334//1.clientX/clientY//e.clientX/e.clientY 鼠标在可视区域中的位置//2.pageX/pageY//e.pageX/e.pageY 鼠标在页面中的位置 有兼容性问题 从IE9以后才支持 //3.最终方案：pageY = clientY + 页面滚动出去的距离//4.页面滚动出去的距离//console.log(document.body.scrollLeft);//console.log(document.body.scrollTop);//但是有些浏览器 是使用document.documentElement来获取的滚动出去的距离的//console.log(document.documentElement.scrollLeft);//console.log(document.documentElement.scrollTop);// 5.获取鼠标在页面的位置，处理浏览器兼容性function getScroll() &#123; var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; return &#123; scrollLeft: scrollLeft, scrollTop: scrollTop &#125;&#125;function getPage(e) &#123; e = e || window.event; var pageX = e.pageX || (e.clientX + getScroll().scrollLeft); var pageY = e.pageY || (e.clientY + getScroll().scrollTop); return &#123; pageX: pageX, pageY: pageY &#125;&#125; 8.4.8 阻止事件传播的方式 事件传递 : 多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发了,外面的元素的该事件自动的触发了。 a) 为什么有事件传播：12345678910111213141516171819//事件可以分为三个阶段* 1.事件捕获阶段 : 从外向内* 2.事件目标阶段 : 最开始选择的那个* 3.事件冒泡阶段 : 从里向外//为元素绑定事件* addEventListener(&quot;没有on的事件类型&quot;,事件处理函数,控制事件阶段的)//addEventListener中第三个参数是控制事件阶段的* 通过e.eventPhase这个属性可以知道当前的事件是什么阶段//如果e.eventPhase这个属性的值是:* 1----&gt;捕获阶段* 2----&gt;目标阶段* 3----&gt;冒泡//一般默认都是冒泡阶段,很少用捕获阶段* 捕获阶段:从外向内* 冒泡阶段:从里向外 1234567891011121314151617181920&lt;div id=&quot;dv1&quot;&gt; &lt;div id=&quot;dv2&quot;&gt; &lt;div id=&quot;dv3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; //事件冒泡:是从里向外 //同时注册点击事件 var objs = [my$(&quot;dv3&quot;), my$(&quot;dv2&quot;), my$(&quot;dv1&quot;)]; //遍历注册事件 objs.forEach(function (ele) &#123; //为每个元素绑定事件 ele.addEventListener(&quot;click&quot;, function (e) &#123; console.log(this.id+&quot;====&gt;&quot;+e.eventPhase); &#125;, true); &#125;);&lt;/script&gt;//在addEventListener函数最后一个参数是true或者false情况下，我们可以看到打印结果的变化 b) 如何阻止事件传播 标准方式 event.stopPropagation(); 谷歌和火狐支持 event.cancelBubble &#x3D; true; 标准中已废弃 IE特有的,谷歌支持,火狐不支持 1234567891011function fun1(e)&#123; alert(&quot;fun1&quot;); //w3c标准 if(e&amp;&amp;e.stopPropagation)&#123; e.stopPropagation(); &#125; //ie else&#123; window.event.cancelBubble = true; &#125;&#125; 8.4.9 阻止默认事件非IE e.preventDefault() IE event.returnValue &#x3D; true; 1234567891011121314&lt;a href=&quot;http://www.baidu.com&quot; onclick=&quot;fn(event)&quot;&gt;点击我吧&lt;/a&gt;function fn(e)&#123; //查看e是否存在preventDefault方法 //火狐浏览器(w3c标准) if(e&amp;&amp;e.preventDefault)&#123; //阻止默认行为 e.preventDefault(); &#125; //ie浏览器(后期版本的ie也遵从了w3c规范) else&#123; window.event.returnValue = true; return false; &#125;&#125; 案例：点击图片切换照片 12345678910111213141516&lt;a id=&quot;ak&quot; href=&quot;images/1.jpg&quot;&gt; &lt;img src=&quot;images/1-small.jpg&quot; alt=&quot;&quot; id=&quot;im&quot;&gt;&lt;/a&gt;document.getElementById(&quot;im&quot;).onclick=function () &#123; this.src=document.getElementById(&quot;ak&quot;).href; if(e&amp;&amp;e.preventDefault)&#123; //阻止默认行为 e.preventDefault(); &#125; //ie浏览器(后期版本的ie也遵从了w3c规范) else&#123; window.event.returnValue = true; return false; &#125;&#125;; 案例：美女相册 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;body&gt;&lt;h2&gt; 美女画廊&lt;/h2&gt;&lt;ul id=&quot;imagegallery&quot;&gt; &lt;li&gt; &lt;a href=&quot;images/1.jpg&quot; title=&quot;美女A&quot;&gt; &lt;img src=&quot;images/1-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女1&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;images/2.jpg&quot; title=&quot;美女B&quot;&gt; &lt;img src=&quot;images/2-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女2&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;images/3.jpg&quot; title=&quot;美女C&quot;&gt; &lt;img src=&quot;images/3-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女3&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;images/4.jpg&quot; title=&quot;美女D&quot;&gt; &lt;img src=&quot;images/4-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女4&quot;/&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;&lt;!--显示大图的--&gt;&lt;img id=&quot;image&quot; src=&quot;images/placeholder.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;p id=&quot;des&quot;&gt;选择一个图片&lt;/p&gt;&lt;script&gt; //点击a标签,把a标签中的href的属性值给id为image的src属性 //把a的title属性的值给id为des的p标签赋值 //从ul中标签获取获取所有的a标签 var aObjs=my$(&quot;imagegallery&quot;).getElementsByTagName(&quot;a&quot;); //循环遍历所有的a标签 for(var i=0;i&lt;aObjs.length;i++)&#123; //为每个a标签注册点击事件 aObjs[i].onclick=function () &#123; //为id为image的标签的src赋值 my$(&quot;image&quot;).src=this.href; //为p标签赋值 my$(&quot;des&quot;).innerText=this.title; //阻止超链接默认的跳转 return false; &#125;; &#125;&lt;/script&gt; 8.4.10 事件委派a) 代理机制代理是一种常用的设计模式，代理模式可以对原有的类进行扩展，即通过代理对象的模式来访问目标类。最通俗的例子就是假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的。明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子。 代理的好处： 1.限制对象的访问权限 2.在不改变目标对象代码的基础上为它动态的添加功能 123456789101112131415161718192021222324252627&lt;script type=&quot;text/javascript&quot;&gt; function Person(name)&#123; this.name = name; this.talkBusiness = function()&#123; console.log(this.name+&quot;谈了1个亿的生意&quot;); &#125; &#125; function Agent(name,p)&#123; this.p = p; this.name = name; this.talkBusiness = function()&#123; //目标对象的目标方法之前做的事情 console.log(&quot;谈生意之前制定计划&quot;); //目标对象调用目标方法 this.p.talkBusiness(); //目标对象的目标方法之后做的事情 console.log(&quot;谈生意之后做总结&quot;); &#125; &#125; //目标对象 var p = new Person(&quot;成龙&quot;); //代理对象 var a = new Agent(&quot;华谊传媒&quot;,p); a.talkBusiness();&lt;/script&gt; b) 练习1、小明(Person类)刚到上海工作，住在公司宿舍，由于刚入职，工作繁忙没有空余时间，他就委托中山房产中介公司(Agent类)和他的朋友小张(Friend类)找房子。 他每天给中介公司或小张打电话，询问有没有合适的房源。他的心理价位是1000元每月。（即小于等于1000的时候，即找到房子） 中介公司周一至周六工作，每天能找到的一处房源的价格800~3000随机 小张周日帮他找，每天能找到一处价格约500~4000的房子 编写程序，运行到找到房子。显示当天星期几，显示每天中介或者小张帮他找到房子的价格。 c) 事件委派的原理什么是事件委托：通俗的讲，事件委派就是onclick/onmouseover/onmouseout等事件委托别人来处理。 事件委派原理：利用冒泡的原理，把事件冒到父级上，触发执行效果。 事件委派好处：提高性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;div id=&quot;menu&quot;&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li class=&quot;current&quot;&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;商品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;博客&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;相册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;帮助&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;style&gt; #list li &#123; list-style-type: none; width: 80px; height: 30px; line-height: 30px; background-color: beige; text-align: center; float: left; margin-left: 5px; &#125; #list li.current &#123; background-color: burlywood; &#125; #list li a &#123; text-decoration: none;&lt;/style&gt;//1.没有事件委派写法&lt;script&gt; //获取所有的li标签, var liObjs=my$(&quot;list&quot;).getElementsByTagName(&quot;li&quot;); //循环遍历,找到每个li中的a,注册点击事件 for(var i=0;i&lt;liObjs.length;i++)&#123; //每个li中的a var aObj=getFirstElement(liObjs[i]); aObj.onclick=function () &#123; //第一件事:把这个a所在的li的所有的兄弟元素的类样式全部移除 for(var j=0;j&lt;liObjs.length;j++)&#123; liObjs[j].removeAttribute(&quot;class&quot;); &#125; //第二件事: //当前点击的a的父级元素li(点击的这个a所在的父级元素li),设置背景颜色 this.parentNode.className=&quot;current&quot;; //第三件事：阻止超链接跳转 if(e&amp;&amp;e.preventDefault)&#123; //阻止默认行为 e.preventDefault(); &#125; //ie浏览器(后期版本的ie也遵从了w3c规范) else&#123; window.event.returnValue = true; return false; &#125; &#125; &#125;&lt;/script&gt;//2.事件委派写法&lt;script&gt; //获取所有的li标签, var list = my$(&quot;list&quot;); var liObjs=my$(&quot;list&quot;).getElementsByTagName(&quot;li&quot;); list.onclick = function(e)&#123; //第一件事:把这个a所在的li的所有的兄弟元素的类样式全部移除 for(var j=0;j&lt;liObjs.length;j++)&#123; liObjs[j].removeAttribute(&quot;class&quot;); &#125; //第二件事：获取事件的触发者 e = e||window.event; var target = e.target; target.parentNode.className=&quot;current&quot;; //第三件事：阻止超链接跳转 if(e&amp;&amp;e.preventDefault)&#123; //阻止默认行为 e.preventDefault(); &#125; //ie浏览器(后期版本的ie也遵从了w3c规范) else&#123; window.event.returnValue = true; return false; &#125;; &#125;&lt;/script&gt; 9. 特效属性9.1 偏移量 offsetParent 离当前元素最近的一个有定位属性的父节点的距离 。如果父亲都没有定位，返回body。 123456789var box = document.getElementById(&#x27;box&#x27;);//注意：通过box.style.width获取不到在style标签中设置的属性值(style属性中可以获取)，所以我们一般不通过box.style.width来获取属性值var box = document.getElementById(&#x27;box&#x27;);console.log(box.offsetParent); //下面offsetLeft和offsetTop都是相当于这个offsetParent而言的console.log(box.offsetLeft); //获取元素到最近一个有定位属性的父节点的左边距离，如果没有定位的父亲，则相对于bodyconsole.log(box.offsetTop); //获取元素到最近一个有定位属性的父节点的上边距离console.log(box.offsetWidth); //绝对宽度，包含边框,不包括因overflow而未显示的部分，也就是其实际占据的宽度console.log(box.offsetHeight); //绝对高度，包含边框,不包括因overflow而未显示的部分，也就是其实际占据的高度 9.2 Client属性12345var box = document.getElementById(&#x27;box&#x27;);console.log(box.clientLeft); //左边框宽度console.log(box.clientTop); //顶边框宽度console.log(box.clientWidth); //获取宽度，包括padding，但是不包括边框console.log(box.clientHeight);//获取宽度，包括padding，但是不包括边框 9.3 滚动偏移12345var box = document.getElementById(&#x27;box&#x27;);console.log(box.scrollLeft) //左边滚动出去的距离console.log(box.scrollTop)console.log(box.scrollWidth) //内容的大小，包括padding 和未显示的内容，不包括滚动条console.log(box.scrollHeight) 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;box&quot;&gt; 小明跟小华到动物园玩，进门时，小明指着小华对看门人说：“看清楚喔！等会儿出来，别说我偷了你们的猴子！” &lt;/div&gt; &lt;style&gt; body &#123; margin: 0; &#125; #box &#123; width: 100px; height: 100px; margin: 50px; border: 30px solid red; padding: 10px; background-color: green; overflow: auto; &#125;&lt;/style&gt;&lt;script&gt; var box = document.getElementById(&#x27;box&#x27;); // 当拖动box中的滚动条的时候触发 box.onscroll = function () &#123; console.log(box.scrollLeft); console.log(box.scrollTop); // 内容的大小，包括padding 和未显示的内容，不包括滚动条 // console.log(box.scrollWidth); // console.log(box.scrollHeight); // 元素的大小 + padding 不包括滚动条 // console.log(box.clientWidth); // console.log(box.clientHeight); &#125;&lt;/script&gt; 9.4 宽度的总结123456789101112131415//实际内容的宽高style.width //返回元素的宽度（包括元素宽度，不包括内边距、边框和外边距）style.height //返回元素的高度（包括元素高度，不包括内边距、边框和外边距）//边框及边框以内offsetWidth //返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）offsetHeight //返回元素的高度（包括元素高度、内边距和边框，不包括外边距）//边框以内clientWidth //返回元素的宽度（包括元素宽度、内边距，不包括边框和外边距）clientHeight //返回元素的高度（包括元素高度、内边距，不包括边框和外边距）//滚动出去的scrollWidth //返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同scrollHeigh //返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同 9.5 案例1.拖拽注册框，点击x关闭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;div class=&quot;nav&quot;&gt; &lt;a href=&quot;javascript:;&quot; id=&quot;register&quot;&gt;注册信息&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;d-box&quot; id=&quot;d_box&quot;&gt; &lt;div class=&quot;hd&quot; id=&quot;drop&quot;&gt;注册信息 (可以拖拽) &lt;span id=&quot;box_close&quot;&gt;【关闭】&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .nav &#123; height: 30px; background: #036663; border-bottom: 1px solid #369; line-height: 30px; padding-left: 30px; &#125; .nav a &#123; color: #fff; text-align: center; font-size: 14px; text-decoration: none; &#125; .d-box &#123; width: 400px; height: 300px; border: 5px solid #eee; box-shadow: 2px 2px 2px 2px #666; position: absolute; top: 40%; left: 40%; background-color: white; /* 不让文字被选中 */ -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; &#125; .hd &#123; width: 100%; height: 25px; background-color: #7c9299; border-bottom: 1px solid #369; line-height: 25px; color: white; cursor: move; &#125; #box_close &#123; float: right; cursor: pointer; &#125;&lt;/style&gt;&lt;script&gt; var box = document.getElementById(&#x27;d_box&#x27;); var drop = document.getElementById(&#x27;drop&#x27;); //1.只有点击drop才可以拖动，所以给drop添加onmousedown事件 drop.onmousedown = function (e) &#123; // 兼容性处理 e = e || window.event; // 2.当鼠标按下的时候，求鼠标在盒子中的位置 // 鼠标在盒子中的位置 = 鼠标在页面上的位置 - 盒子的位置 var x = getPage(e).pageX - box.offsetLeft; var y = getPage(e).pageY - box.offsetTop; // 3.鼠标按住不放 同时 鼠标在文档中移动，此时可以拖动box document.onmousemove = function (e) &#123; e = e || window.event; // 当鼠标在页面上移动的时候。求盒子的坐标 // 盒子的坐标 = 鼠标当前在页面中的位置 - 鼠标在盒子中的位置 var boxX = getPage(e).pageX - x; var boxY = getPage(e).pageY - y; box.style.left = boxX + &#x27;px&#x27;; box.style.top = boxY + &#x27;px&#x27;; &#125; &#125; //4.当鼠标弹起的时候，移除鼠标移动事件 document.onmouseup = function () &#123; document.onmousemove = null; &#125; //5.点击关闭按钮，隐藏盒子 var box_close = document.getElementById(&#x27;box_close&#x27;); box_close.onclick = function () &#123; box.style.display = &#x27;none&#x27;; &#125;&lt;/script&gt; 案例2：弹出注册框，可拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;div class=&quot;login-header&quot;&gt;&lt;a id=&quot;link&quot; href=&quot;javascript:void(0);&quot;&gt;点击，弹出登录框&lt;/a&gt;&lt;/div&gt;&lt;div id=&quot;login&quot; class=&quot;login&quot; &gt; &lt;div id=&quot;title&quot; class=&quot;login-title&quot;&gt;登录会员 &lt;span&gt;&lt;a id=&quot;closeBtn&quot; href=&quot;javascript:void(0);&quot; class=&quot;close-login&quot;&gt;关闭&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;login-input-content&quot;&gt; &lt;div class=&quot;login-input&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; name=&quot;info[username]&quot; id=&quot;username&quot; class=&quot;list-input&quot;&gt; &lt;/div&gt; &lt;div class=&quot;login-input&quot;&gt; &lt;label&gt;登录密码：&lt;/label&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入登录密码&quot; name=&quot;info[password]&quot; id=&quot;password&quot; class=&quot;list-input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;loginBtn&quot; class=&quot;login-button&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot; id=&quot;login-button-submit&quot;&gt;登录会员&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 遮盖层 --&gt;&lt;div id=&quot;bg&quot; class=&quot;login-bg&quot; &gt;&lt;/div&gt; &lt;style&gt; .login-header &#123; width: 100%; text-align: center; height: 30px; font-size: 24px; line-height: 30px; &#125; ul, li, ol, dl, dt, dd, div, p, span, h1, h2, h3, h4, h5, h6, a &#123; padding: 0px; margin: 0px; &#125; .login &#123; width: 512px; height: 280px; position: absolute; border: #ebebeb solid 1px; left: 50%; right: 50%; background: #ffffff; box-shadow: 0px 0px 20px #ddd; z-index: 9999; margin-left: -256px; margin-top: 140px; display: none; &#125; .login-title &#123; width: 100%; margin: 10px 0px 0px 0px; text-align: center; line-height: 40px; height: 40px; font-size: 18px; position: relative; cursor: move; -moz-user-select:none;/*火狐 用户无法再该文本块中选择文本*/ -webkit-user-select:none;/*webkit浏览器*/ -ms-user-select:none;/*IE10*/ -khtml-user-select:none;/*早期浏览器*/ user-select:none; &#125; .login-input-content &#123; margin-top: 20px; &#125; .login-button &#123; width: 50%; margin: 30px auto 0px auto; line-height: 40px; font-size: 14px; border: #ebebeb 1px solid; text-align: center; &#125; .login-bg &#123; width: 100%; height: 100%; position: fixed; top: 0px; left: 0px; background: #000000; filter: alpha(opacity=30); -moz-opacity: 0.3; -khtml-opacity: 0.3; opacity: 0.3; display: none; &#125; a &#123; text-decoration: none; color: #000000; &#125; .login-button a &#123; display: block; &#125; .login-input input.list-input &#123; float: left; line-height: 35px; height: 35px; width: 350px; border: #ebebeb 1px solid; text-indent: 5px; &#125; .login-input &#123; overflow: hidden; margin: 0px 0px 20px 0px; &#125; .login-input label &#123; float: left; width: 90px; padding-right: 10px; text-align: right; line-height: 35px; height: 35px; font-size: 14px; &#125; .login-title span &#123; position: absolute; font-size: 12px; right: -20px; top: -30px; background: #ffffff; border: #ebebeb solid 1px; width: 40px; height: 40px; border-radius: 20px; &#125;&lt;/style&gt;&lt;script&gt; // 显示登录框和遮盖层 var login = document.getElementById(&#x27;login&#x27;); var bg = document.getElementById(&#x27;bg&#x27;); //1 点击按钮，弹出登录框和遮盖层 var link = document.getElementById(&#x27;link&#x27;); link.onclick = function () &#123; login.style.display = &#x27;block&#x27;; bg.style.display = &#x27;block&#x27;; return false; &#125; // 2 点击关闭按钮，隐藏 登录框和遮盖层 var closeBtn = document.getElementById(&#x27;closeBtn&#x27;); closeBtn.onclick = function () &#123; // 隐藏 登录框和遮盖层 login.style.display = &#x27;none&#x27;; bg.style.display = &#x27;none&#x27;; &#125; // 3 拖拽 var title = document.getElementById(&#x27;title&#x27;); title.onmousedown = function (e) &#123; // 鼠标按下，求鼠标在盒子中的位置 var x = e.pageX - login.offsetLeft; var y = e.pageY - login.offsetTop; document.onmousemove = function (e) &#123; // 鼠标移动的时候， 盒子的坐标 var loginX = e.pageX - x; var loginY = e.pageY - y; login.style.left = loginX + 256 + &#x27;px&#x27;; login.style.top = loginY - 140 + &#x27;px&#x27;; &#125; &#125; document.onmouseup = function () &#123; // 移除鼠标移动的事件 document.onmousemove = null; &#125;&lt;/script&gt; 案例：放大镜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;div class=&quot;small&quot;&gt; &lt;img src=&quot;images/small.png&quot; width=&quot;350&quot; alt=&quot;&quot;/&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;big&quot;&gt; &lt;img src=&quot;images/big.jpg&quot; width=&quot;800&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;* &#123; margin: 0; padding: 0;&#125; .box &#123; width: 350px; margin: 100px; border: 1px solid #ccc; position: relative;&#125;/*big的宽度为400，但是big下的img宽度为800，设置了big的overflow为hidden，所以图片只看到一部分*/.big &#123; width: 400px; height: 400px; position: absolute; top: 0; left: 360px; border: 1px solid #ccc; overflow: hidden; display: none;&#125;.big img &#123; position: absolute; border:1px solid red;&#125;/*遮盖层，鼠标移上去的时候显示的黄色小块*/.mask &#123; width: 175px; height: 175px; background: rgba(255, 255, 0, 0.4); position: absolute; top: 0px; left: 0px; cursor: move; display: none;&#125;.small &#123; position: relative;&#125;&lt;/style&gt;&lt;script&gt; //找到box var box = my$(&#x27;box&#x27;); //分别找到box下的smallBox和bigBox var smallBox = box.children[0]; var bigBox = box.children[1]; //找到smallImage 找到mask 找到bigImage var smallImage = smallBox.children[0]; var mask = smallBox.children[1]; var bigImage = bigBox.children[0]; // 1 鼠标经过的时候 显示 mask和bigBox ， 当鼠标离开box的时候隐藏mask和bigBox // // mouseenter mouseleave 不会触发事件冒泡 // mouseover mouseout 会触发事件冒泡 box.onmouseenter = function () &#123; // 显示 mask和bigBox mask.style.display = &#x27;block&#x27;; bigBox.style.display = &#x27;block&#x27; &#125; box.onmouseleave = function () &#123; mask.style.display = &#x27;none&#x27;; bigBox.style.display = &#x27;none&#x27;; &#125; // 2 当鼠标在盒子中移动的时候，让mask和鼠标一起移动 box.onmousemove = function (e) &#123; e = e || window.event; // 获取鼠标在盒子中的位置，就是mask的坐标 var maskX = getPage(e).pageX - box.offsetLeft; var maskY = getPage(e).pageY - box.offsetTop; // 让鼠标出现在mask的中心点 maskX = maskX - mask.offsetWidth / 2; maskY = maskY - mask.offsetHeight / 2; // 把mask限制到box中 maskX = maskX &lt; 0 ? 0 : maskX; maskY = maskY &lt; 0 ? 0 : maskY; maskX = maskX &gt; box.offsetWidth - mask.offsetWidth ? box.offsetWidth - mask.offsetWidth : maskX; maskY = maskY &gt; box.offsetHeight - mask.offsetHeight ? box.offsetHeight - mask.offsetHeight : maskY; mask.style.left = maskX + &#x27;px&#x27;; mask.style.top = maskY + &#x27;px&#x27;; // 3 当mask移动的时候，让大图片移动 // 求 大图片移动的距离 // mask移动的距离 / mask最大能够移动的距离 = 大图片移动的距离 / 大图片最大能够移动的距离 // mask最大能够移动的距离 var maskMax = box.offsetWidth - mask.offsetWidth; // 大图片最大能够移动的距离 var bigImageMax = bigImage.offsetWidth - bigBox.offsetWidth; var bigImageX = maskX * bigImageMax / maskMax; var bigImageY = maskY * bigImageMax / maskMax; bigImage.style.left = -bigImageX + &#x27;px&#x27;; bigImage.style.top = -bigImageY + &#x27;px&#x27;; &#125;&lt;/script&gt; 案例：模拟滚动条 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;div class=&quot;content&quot; id=&quot;content&quot;&gt; 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， 我是文字内容，我是文字内容，我是文字内容， &lt;/div&gt; &lt;div class=&quot;scroll&quot; id=&quot;scroll&quot;&gt; &lt;div class=&quot;bar&quot; id=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123;margin: 0;padding: 0;&#125; .box &#123; width: 300px; height: 500px; border: 1px solid red; margin: 100px; position: relative; overflow: hidden; /* 不让文字被选中 */ -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; &#125; .content &#123; padding: 5px 18px 5px 5px; position: absolute; top: 0; left: 0; &#125; .scroll &#123; width: 18px; height: 100%; position: absolute; top: 0; right: 0; background-color: #eee; &#125; .bar &#123; height: 100px; width: 100%; position: absolute; top: 0; left: 0; background-color: red; border-radius: 10px; cursor: pointer; &#125;&lt;/style&gt;&lt;script&gt; var box = my$(&#x27;box&#x27;); var content = my$(&#x27;content&#x27;); var scroll = my$(&#x27;scroll&#x27;); var bar = my$(&#x27;bar&#x27;); //1 根据内容的大小，计算滚动条的高度 // 滚动条的高度 / scroll的高度 = box的高度 / 内容的高度 // offsetHeight 元素的大小 + padding + border // clientHeight 元素的大小 + padding // scrollHeight 内容的大小 + padding // 当内容的高度大于box的高度，再计算 滚动条的高度，否则的话滚动条的高度为0 var barHeight = 0; if (content.scrollHeight &gt; box.clientHeight) &#123; barHeight = box.clientHeight / content.scrollHeight * scroll.clientHeight; &#125; bar.style.height = barHeight + &#x27;px&#x27;; //2 让滚动条能够拖拽 // 2.1 当鼠标按下的时候，求鼠标在滚动条中的位置 bar.onmousedown = function (e) &#123; e = e || window.event; // 鼠标在滚动条中的位置 var y = getPage(e).pageY - bar.offsetTop - box.offsetTop; // 2.2 当鼠标在页面上移动的时候，求滚动条的位置 document.onmousemove = function (e) &#123; //求滚动条的位置 var barY = getPage(e).pageY - y - box.offsetTop; // 控制bar不能移出scroll barY = barY &lt; 0 ? 0 : barY; barY = barY &gt; scroll.clientHeight - bar.clientHeight ? scroll.clientHeight - bar.clientHeight : barY; bar.style.top = barY + &#x27;px&#x27;; //3 当拖拽滚动条的时候，改变内容的位置 // 内容滚动的距离 / 内容最大能够滚动的距离 = 滚动条滚动的距离 / 滚动条最大能够滚动的距离 // 内容最大能够滚动的距离 var contentMax = content.scrollHeight - box.clientHeight; // 滚动条最大能够滚动的距离 var barMax = scroll.clientHeight - bar.clientHeight; var contentY = barY / barMax * contentMax; content.style.top = -contentY + &#x27;px&#x27;; &#125; &#125; document.onmouseup = function () &#123; // 移除鼠标移动的事件 document.onmousemove = null; &#125;&lt;/script&gt; 10. BOM10.1 BOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 10.2 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window 12window 皇上document 太监总管(document也是window中的对象) 注意： window下一个特殊的属性 window.name 12345678910111213141516//页面中所有内容都是window的var name = 123;console.log(name);//window下本身就有一个name属性，他的值是空字符串，即使我们给他赋值一个数值，但他还是一个字符串（注意查看打印的颜色）//这边其实打印的时候省略了console.log(window.name);var age = 123;console.log(age); // ---&gt;console.log(window.age);var top = &quot;top&quot;;console.log(top);//这边打印出来的是Window，top本身是window的一个属性，不能被赋值function f1() &#123; console.log(&quot;这里的this是&quot;+this);&#125;f1(); //----&gt;window.f1(); 10.3 对话框1234window.alert(&quot;您好啊&quot;);//以后不用,测试的时候使用window.prompt(&quot;请输入帐号&quot;);var result=window.confirm(&quot;您确定退出吗&quot;);console.log(result); 10.4 页面加载事件 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&#125; onunload 123window.onunload = function () &#123; // 当用户退出页面时执行&#125; onbeforeunload 1234//页面关闭之前触发的window.onbeforeunload=function () &#123; alert(&quot;哈哈&quot;);&#125;; 10.5 location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL 10.5.1 URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 1234567891011121314scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个&#x27;/&#x27;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用&#x27;&amp;&#x27;符号隔开，每个参数的名和值用&#x27;=&#x27;符号隔开。例如： name=zsfragment:信息片断 字符串，锚点. 10.5.2 location的成员 使用chrome的控制台查看 查MDN MDN 12345678910111213console.log(window.location);console.log(window.location.hash); //得到地址栏中#号及后面内容console.log(window.location.host); //主机和端口号console.log(window.location.hostname); //主机名console.log(window.location.port); //端口号console.log(window.location.protocol); //协议console.log(window.location.search); //搜索内容，泛指?号及后面内容console.log(window.location.href); //地址window.location.href = &quot;http://www.baidu.com&quot;; //设置新地址(会加入浏览器历史记录)window.location.assign(&quot;http://www.baidu.com&quot;); //设置新地址，等同于上面href属性(会加入浏览器历史记录)window.location.reload(); //重新加载网页window.location.replace(&quot;http://www.baidu.com&quot;); //替换当前网页(没有浏览器的历史记录) 10.5.3 案例解析URL中的query，并返回对象的形式 1234567891011121314151617//http://baidu.com?name=&quot;&quot;&amp;age=1function getQuery(queryStr) &#123; var query = &#123;&#125;; if (queryStr.indexOf(&#x27;?&#x27;) &gt; -1) &#123; var index = queryStr.indexOf(&#x27;?&#x27;); queryStr = queryStr.substr(index + 1); var array = queryStr.split(&#x27;&amp;&#x27;); for (var i = 0; i &lt; array.length; i++) &#123; var tmpArr = array[i].split(&#x27;=&#x27;); if (tmpArr.length === 2) &#123; query[tmpArr[0]] = tmpArr[1]; &#125; &#125; &#125; return query;&#125;console.log(getQuery(location.href)); 10.6 history对象 back() 后退 forward() 前进 go() 跳转下一页面 1上图中，点击页面1中的 跳(go方法) 按钮来到第二个页面，点击第二个页面的后退按钮(back方法)来到第一个页面，点击第一个页面的前进(forward方法)来到第二个页面 10.7 navigator对象 userAgent 通过userAgent可以判断用户浏览器的类型 platform 通过platform可以判断浏览器所在的系统平台类型. 12console.log(window.navigator.platform); //查看操作系统平台信息console.log(window.navigator.userAgent); //查看浏览器类型，每个浏览器都不一样。可以通过该属性判断客户端环境，切换不同的页面。(电脑端一个页面，手机端一个页面) 10.8 定时器10.8.1 setTimeout()和clearTimeout()在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () &#123; console.log(&#x27;Hello World&#x27;);&#125;, 1000);// 取消定时器的执行clearTimeout(timerId); 10.8.2 案例1.删除提示 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; body &#123; margin: 0; padding: 0; &#125; #tip &#123; width: 150px; height: 30px; background-color: lightgray; opacity: 0.5; margin:200px auto; padding-top: 5px; text-align: center; color: red; display: none; &#125;&lt;/style&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;删除&quot;&gt;&lt;div id=&quot;tip&quot;&gt;删除成功&lt;/div&gt;&lt;script&gt; // 当页面的所有元素创建完成, 等待外部文件下载完毕才会执行 var btn = document.getElementById(&#x27;btn&#x27;); btn.onclick = function () &#123; // 删除操作 // 显示删除成功的tip var tip = document.getElementById(&#x27;tip&#x27;); tip.style.display = &#x27;block&#x27;; // 隔3秒钟之后让tip隐藏 setTimeout(function () &#123; tip.style.display = &#x27;none&#x27;; &#125;, 3000); &#125;&lt;/script&gt; 10.8.3 setInterval()和clearInterval()定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数 12345678// 创建一个定时器，每隔1秒调用一次var timerId = setInterval(function () &#123; var date = new Date(); console.log(date.toLocaleTimeString());&#125;, 1000);// 取消定时器的执行clearInterval(timerId); 10.8.4 案例1.摇起来 12345678910111213141516171819202122232425262728293031323334353637&lt;input type=&quot;button&quot; value=&quot;摇起来&quot; id=&quot;btn1&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;停止&quot; id=&quot;btn2&quot;/&gt;&lt;div id=&quot;dv&quot;&gt; &lt;img src=&quot;images/heihei.jpg&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;images/lyml.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;style&gt; img &#123; width: 200px; height: 200px; &#125; div &#123; position: absolute; &#125;&lt;/style&gt;&lt;script&gt; //点击按钮摇起来 var timeId=&quot;&quot;; my$(&quot;btn1&quot;).onclick = function () &#123; timeId= setInterval(function () &#123; //随机数 var x = parseInt(Math.random() * 100 + 1); var y = parseInt(Math.random() * 100 + 1); //设置元素的left和top属性值 my$(&quot;dv&quot;).style.left = x + &quot;px&quot;; my$(&quot;dv&quot;).style.top = y + &quot;px&quot;; &#125;, 10); &#125;; my$(&quot;btn2&quot;).onclick=function () &#123; clearInterval(timeId); &#125;;&lt;/script&gt; 案例2：星星 12345678910111213141516171819202122232425262728293031&lt;input type=&quot;button&quot; value=&quot;亮起来&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;style&gt; div&#123; width: 600px; height: 600px; border:2px solid yellow; background-color: black; position: relative; &#125; span&#123; font-size: 30px; color: yellow; position: absolute; &#125;&lt;/style&gt;&lt;script&gt; my$(&quot;btn&quot;).onclick=function () &#123; setInterval(function () &#123; my$(&quot;dv&quot;).innerHTML=&quot;&lt;span&gt;★&lt;/span&gt;&quot;; var x = parseInt(Math.random() * 600 + 1); var y = parseInt(Math.random() * 600 + 1); my$(&quot;dv&quot;).firstElementChild.style.left=x+&quot;px&quot;; my$(&quot;dv&quot;).firstElementChild.style.top=y+&quot;px&quot;; &#125;,50); &#125;;&lt;/script&gt; 案例3：美女时钟 1234567891011121314151617181920&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;im&quot; /&gt;&lt;script&gt; function f1() &#123; //获取当前时间 var dt = new Date(); //获取小时 var hour = dt.getHours(); //获取秒 var second = dt.getSeconds(); hour = hour &lt; 10 ? &quot;0&quot; + hour : hour; second = second &lt; 10 ? &quot;0&quot; + second : second; my$(&quot;im&quot;).src=&quot;meimei/&quot;+hour+&quot;_&quot;+second+&quot;.jpg&quot;; &#125; f1(); //页面加载完毕后,过了1秒才执行函数的代码 setInterval(f1,1000);&lt;/script&gt; 4.案例：协议按钮禁用 12345678910111213141516171819&lt;textarea name=&quot;texta&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt; 这个世界就是这么疯狂,你不同意,我就让你注册,秦始皇,打钱&lt;/textarea&gt;&lt;input type=&quot;button&quot; value=&quot;请仔细阅读协议(5)&quot; id=&quot;btn&quot; disabled=&quot;disabled&quot; /&gt;&lt;script&gt; var time=5; var timeId= setInterval(function () &#123; time--; my$(&quot;btn&quot;).value=&quot;请仔细阅读协议(&quot;+time+&quot;)&quot;; if(time&lt;=0)&#123; //停止定时器就可以 clearInterval(timeId); //按钮可以被点击了 my$(&quot;btn&quot;).disabled=false; my$(&quot;btn&quot;).value=&quot;同意&quot;; &#125; &#125;,1000);&lt;/script&gt; 5.案例：设置div透明度渐变 1234567891011121314151617&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;渐变&quot; id=&quot;btn&quot;/&gt; my$(&quot;btn&quot;).onclick=function () &#123; var opacity = 10; //按钮的点击事件 var timeId=setInterval(function () &#123; //透明化了 opacity--; if(opacity&lt;=0)&#123; clearInterval(timeId);//清理定时器 &#125; //设置div的透明度 my$(&quot;dv&quot;).style.opacity=opacity/10; &#125;,200); &#125;; 6.案例：设置div的宽度 1234567891011121314151617181920212223242526&lt;input type=&quot;button&quot; value=&quot;变宽&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;var dv = my$(&quot;dv&quot;);my$(&quot;btn&quot;).onclick = function()&#123; //宽度的目标值 var target = 791; //获取原来宽度 var width = dv.offsetWidth; //开启定时器 var timeid = setInterval(function()&#123; //确定步进 var step = 10; //判断目标值和当前值大小 if(Math.abs(target-width) &lt; step)&#123; console.log(&quot;qingchu&quot;); dv.style.width = target + &quot;px&quot;; clearInterval(timeid); return; &#125; width += step; //把current设置给dv dv.style.width = width + &quot;px&quot;; &#125;,100);&#125; 7.案例：移动元素 12345678910111213141516171819202122232425262728293031323334353637383940&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;移动到800px&quot; id=&quot;btn2&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script&gt; var dv = my$(&quot;dv&quot;); var left = dv.offsetLeft; my$(&quot;btn1&quot;).onclick = function()&#123; var target = 400; var timeid = setInterval(function()&#123; var step = 10; if(Math.abs(target - left) &lt; step)&#123; dv.style.left = target + &quot;px&quot;; console.log(&quot;终止&quot;); clearInterval(timeid); return; &#125; left += step; dv.style.left = left + &quot;px&quot;; &#125;,50); &#125; my$(&quot;btn2&quot;).onclick = function()&#123; var target = 800; var timeid = setInterval(function()&#123; var step = 10; if(Math.abs(target - left) &lt; step)&#123; dv.style.left = target + &quot;px&quot;; console.log(&quot;终止&quot;); clearInterval(timeid); return; &#125; left += step; dv.style.left = left + &quot;px&quot;; &#125;,50); &#125;&lt;/script&gt; 10.8.5 动画函数的初步封装12345678910111213141516171819202122232425262728293031//移动动画函数的封装function animate(element, target) &#123; // 通过判断，保证页面上只有一个定时器在执行动画 if (element.timerId) &#123; clearInterval(element.timerId); element.timerId = null; &#125; element.timerId = setInterval(function () &#123; // 步进 每次移动的距离 var step = 10; // 盒子当前的位置 var current = element.offsetLeft; // 判断如果当前位置 &gt; 目标位置 此时的step 要小于0 if (current &gt; target) &#123; step = - Math.abs(step); &#125; if (Math.abs(current - target) &lt;= Math.abs(step)) &#123; // 让定时器停止 clearInterval(element.timerId); // 让盒子到target的位置 element.style.left = target + &#x27;px&#x27;; return; &#125; // 移动盒子 current += step; element.style.left = current + &#x27;px&#x27;; &#125;, 200);&#125; 10.8.6 图片轮播123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;div class=&quot;all&quot; id=&#x27;box&#x27;&gt; &lt;div class=&quot;screen&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/1m.jpg&quot; width=&quot;500&quot; height=&quot;300&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2m.jpg&quot; width=&quot;500&quot; height=&quot;300&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3m.jpg&quot; width=&quot;500&quot; height=&quot;300&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4m.jpg&quot; width=&quot;500&quot; height=&quot;300&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5m.jpg&quot; width=&quot;500&quot; height=&quot;300&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div id=&quot;arr&quot;&gt;&lt;span id=&quot;left&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span id=&quot;right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; &#125; .screen &#123; width: 500px; height: 200px; overflow: hidden; position: relative; &#125; .screen li &#123; width: 500px; height: 300px; overflow: hidden; float: left; &#125; .screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; &#125; .all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; #arr &#123; display: none; z-index: 1000; &#125; #arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: &#x27;黑体&#x27;; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; &#125; #arr #right &#123; right: 5px; left: auto; &#125;&lt;/style&gt; // 1.获取元素 var box = my$(&#x27;box&#x27;); var screen = box.children[0]; var ul = screen.children[0]; var ol = screen.children[1]; // 箭头 arrow var arr = my$(&#x27;arr&#x27;); var arrLeft = my$(&#x27;left&#x27;); var arrRight = my$(&#x27;right&#x27;); // 图片的宽度 var imgWidth = screen.offsetWidth; // 2.动态生成ol下的li.页面上总共有多少张图片就生成多少个li var count = ul.children.length; for (var i = 0; i &lt; count; i++) &#123; var li = document.createElement(&#x27;li&#x27;); ol.appendChild(li); setInnerText(li, i + 1); //给每一个ol下的li绑定事件 li.onclick = liClick; // 让当前li记录他的索引 // 设置标签的自定义属性 li.setAttribute(&#x27;index&#x27;, i); &#125; //3.ol下的li的点击事件 function liClick() &#123; // 3.1 取消其它li的高亮显示，让当前li高亮显示 for (var i = 0; i &lt; ol.children.length; i++) &#123; var li = ol.children[i]; li.className = &#x27;&#x27;; &#125; // 3.2 让当前li高亮显示 this.className = &#x27;current&#x27;; // 3.3 点击序号，动画的方式切换到当前点击的图片位置 // 获取自定义属性 var liIndex = parseInt(this.getAttribute(&#x27;index&#x27;)); animate(ul, -liIndex * imgWidth); // 全局变量index 和 li中的index保持一致 index = liIndex; &#125; // 让ol下序号1的li默认高亮显示 ol.children[0].className = &#x27;current&#x27;; //4.无缝滚动,获取ul中的第一个li并克隆一份追加到ul最后 var firstLi = ul.children[0]; // 克隆li cloneNode() 复制节点 // 参数 true 复制节点中的内容 // false 只复制当前节点，不复制里面的内容 var cloneLi = firstLi.cloneNode(true); ul.appendChild(cloneLi); //5.实现上一张和下一张的功能 //5.1 下一张 var index = 0; // 第一张图片的索引 arrRight.onclick = function () &#123; // 判断是否是克隆的图片，如果是克隆的图片，此时修改ul的坐标，显示真正的第一张图片 if (index === count) &#123; ul.style.left = &#x27;0px&#x27;; index = 0; &#125; // 总共有5张图片，但是还有一张克隆的图片 克隆的图片的索引是5 // 总count为5个 // index对应li的下标 取值范围为 0~4 // index++取值范围为 1~5 index++; if (index &lt; count) &#123; // animate(ul, -index * imgWidth); // 获取图片对应的序号，让序号点击 ol.children[index].click(); &#125; else &#123; //如果是最后一张图片,以动画的方式，移动到克隆的图片(克隆的图片在所有图片的最后) animate(ul, -index * imgWidth); // 取消所有序号的高亮显示，让第一序号高亮显示 for (var i = 0; i &lt; ol.children.length; i++) &#123; var li = ol.children[i]; li.className = &#x27;&#x27;; &#125; //移动到克隆图片之后，让第0个ol下的li选中 ol.children[0].className = &#x27;current&#x27;; &#125; &#125; // 5.2 上一张 arrLeft.onclick = function () &#123; // 如果当前是第一张图片，此时要偷偷的切换到最后一张图片的位置（克隆的第一张图片） if (index === 0) &#123; index = count; ul.style.left = - index * imgWidth + &#x27;px&#x27;; &#125; index--; ol.children[index].click(); &#125; //6.鼠标放到盒子上显示箭头，关闭定时器 box.onmouseenter = function () &#123; arr.style.display = &#x27;block&#x27;; // 清除定时器 clearInterval(timerId); &#125; //7.鼠标移开盒子隐藏箭头并开启定时器 box.onmouseleave = function () &#123; arr.style.display = &#x27;none&#x27;; // 重新开启定时器 timerId = setInterval(function () &#123; arrRight.click(); &#125;, 2000); &#125; //8.自动切换图片(定时器) var timerId = setInterval(function () &#123; // 切换到下一张图片 arrRight.click(); &#125;, 2000); 10.8.7 动画函数的封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;style&gt; #dv&#123; width: 75px; height: 25px; background-color: red; position: absolute; left: 100px; &#125;&lt;/style&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot; id=&quot;btn1&quot;&gt;&lt;script&gt; //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element, attr) &#123; return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr] || 0; &#125; function animate(element, json, fn) &#123; clearInterval(element.timeId);//清理定时器 //定时器,返回的是定时器的id element.timeId = setInterval(function () &#123; var flag = true;//默认,假设,全部到达目标 //遍历json对象中的每个属性还有属性对应的目标值 for (var attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == &quot;opacity&quot;) &#123; //获取元素的当前的透明度,当前的透明度放大100倍 var current = getStyle(element, attr) * 100; //目标的透明度放大100倍 var target = json[attr] * 100; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if (Math.abs(current - target) &lt;= Math.abs(step))&#123; // 让定时器停止 clearInterval(element.timerId); // 让盒子到target的位置 element.style[attr] = target / 100; &#125; else&#123; current += step;//移动后的值 element.style[attr] = current / 100; &#125; &#125; else if (attr == &quot;zIndex&quot;) &#123; //判断这个属性attr中是不是zIndex //层级改变就是直接改变这个属性的值 element.style[attr] = json[attr]; &#125; else &#123; //普通的属性 //获取元素这个属性的当前的值 var current = parseInt(getStyle(element, attr)); //当前的属性对应的目标值 var target = json[attr]; //移动的步数 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if (Math.abs(current - target) &lt;= Math.abs(step))&#123; // 让定时器停止 clearInterval(element.timerId); // 让盒子到target的位置 element.style[attr] = target + &#x27;px&#x27;; &#125; else&#123; current += step;//移动后的值 element.style[attr] = current + &quot;px&quot;; &#125; &#125; //测试代码 console.log(&quot;目标:&quot; + target + &quot;,当前:&quot; + current + &quot;,每次的移动步数:&quot; + step); //是否到达目标 if (current != target) &#123; flag = false; &#125; &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数 if (fn) &#123; fn(); &#125; &#125; &#125;, 20); &#125; //zIndex:1000 //透明度: 数字类型----小数---放大100倍 my$(&quot;btn1&quot;).onclick = function () &#123; var json1 = &#123;&quot;width&quot;: 400, &quot;height&quot;: 500, &quot;left&quot;: 500, &quot;top&quot;: 80, &quot;opacity&quot;: 0.2&#125;; animate(my$(&quot;dv&quot;), json1, function () &#123; animate(my$(&quot;dv&quot;), &#123;&quot;width&quot;: 40, &quot;height&quot;: 50, &quot;left&quot;: 0, &quot;top&quot;: 0, &quot;opacity&quot;: 1, &quot;zIndex&quot;: 1000&#125;); &#125;); &#125;;&lt;/script&gt; 10.8.8 案例1.小米官网：手风琴案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;style&gt; ul &#123; list-style: none; &#125; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 1150px; height: 400px; margin: 50px auto; border: 1px solid red; overflow: hidden; &#125; div li &#123; width: 240px; height: 400px; float: left; &#125; div ul &#123; width: 1300px; &#125;&lt;/style&gt;&lt;script&gt;//使用之前封装的动画//先获取所有的li标签 var list = my$(&quot;box&quot;).getElementsByTagName(&quot;li&quot;); for (var i = 0; i &lt; list.length; i++) &#123; list[i].style.backgroundImage = &quot;url(images/&quot; + (i + 1) + &quot;.jpg)&quot;; //鼠标进入 list[i].onmouseover = mouseoverHandle; //鼠标离开 list[i].onmouseout = mouseoutHandle; &#125; //进入 function mouseoverHandle() &#123; for (var j = 0; j &lt; list.length; j++) &#123; animate(list[j], &#123;&quot;width&quot;: 100&#125;);//动画效果 &#125; animate(this, &#123;&quot;width&quot;: 800&#125;); &#125; //离开 function mouseoutHandle() &#123; for (var j = 0; j &lt; list.length; j++) &#123; animate(list[j], &#123;&quot;width&quot;: 240&#125;);//动画效果 &#125; &#125;&lt;/script&gt; 2.开机动画 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;span id=&quot;closeButton&quot;&gt;&lt;/span&gt; &lt;div class=&quot;hd&quot; id=&quot;headPart&quot;&gt; &lt;img src=&quot;images/t.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot; id=&quot;bottomPart&quot;&gt; &lt;img src=&quot;images/b.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 322px; position: fixed; bottom: 0; right: 0; overflow: hidden; &#125; span &#123; position: absolute; top: 0; right: 0; width: 30px; height: 20px; cursor: pointer; &#125;&lt;/style&gt;&lt;script&gt; my$(&quot;closeButton&quot;).onclick=function () &#123; //设置最下面的div的高渐渐的变成0 animate(my$(&quot;bottomPart&quot;),&#123;&quot;height&quot;:0&#125;,function () &#123; animate(my$(&quot;box&quot;),&#123;&quot;width&quot;:0&#125;); &#125;); &#125;;&lt;/script&gt; 3、回到顶部。页面和css参照代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;script&gt; // 获取元素 var bodyTop = my$(&#x27;top&#x27;); // top 是window自带的一个属性，此属性是只读的。此属性默认是window对象 // 回到顶部的按钮 var totop = my$(&#x27;totop&#x27;); // 当拖动滚动条的时候执行 window.onscroll = function () &#123; //1 当拖动滚动条的时候，当内容滚动出去 10px的时候，改变top的高度，并且显示回到顶部按钮 // 调用common.js getScroll函数，获取页面滚动出去的距离 var scrollTop = getScroll().scrollTop; console.log(scrollTop); if (scrollTop &gt; 10) &#123; // 改变top bodyTop.className = &#x27;header fixed&#x27;; // 显示回到顶部 totop.style.display = &#x27;block&#x27;; &#125; else &#123; // 改变top bodyTop.className = &#x27;header&#x27;; // 显示回到顶部 totop.style.display = &#x27;none&#x27;; &#125; // 如何获取滚动距离 // document.body.scrollTop // documentElement 网页中的根元素 html // document.documentElement.scrollTop &#125; //2 当点击回到顶部按钮的时候，动画的方式，回到最上面，让滚动距离为0 var timerId = null; totop.onclick = function () &#123; if (timerId) &#123; clearInterval(timerId); timerId = null; &#125; timerId = setInterval(function () &#123; // 步进 每次移动的距离 var step = 10; // 目标位置 var target = 0; // 获取当前位置 var current = getScroll().scrollTop; if (current &gt; target) &#123; step = -Math.abs(step); &#125; // 判断当前是否到达目标位置 if (Math.abs(current - target) &lt;= Math.abs(step)) &#123; clearInterval(timerId); document.body.scrollTop = target; document.documentElement.scrollTop = target; return; &#125; current += step; document.body.scrollTop = current; document.documentElement.scrollTop = current; &#125;, 5); &#125;&lt;/script&gt; 10.8.9 setInterval()定时器的问题a) 进程进程：正在内存中运行的应用程序，每个进程都有自己独立的内存空间。 思考：单核CPU下计算机如何同时运行多个应用程序。 单核CPU下，同一时间片只能运行一个应用程序，我们所看到的同时运行多个应用程序只不过是CPU在各个应用程序之间进行了快速切换。 b) 线程线程：负责了进程中对应代码的执行（执行单元） 多线程：在一个进程中同时运行的多个任务，所有线程共享进程的所有资源。（比如360安全卫士：同时扫描木马\\清理垃圾） 进程进行CPU的资源争夺其实质是进程中的线程在进行CPU的资源争夺，CPU在各个应用程序的线程之间快速切换。 c) js是单线程的 单线程意味着下一段代码必须在当前代码执行完了才能执行。 单线程即任务是串行的，后一个任务需要等待前一个任务的执行，这就可能出现长时间的等待 所以如果setInterval内执行的计算过于耗时,或者有其他耗时任务在执行,setInterval的计时会越来越不准,延迟很厉害。 12345678910111213141516171819202122232425262728293031323334setInterval(function()&#123; var i = 0; while(i++ &lt; 1000000000); console.log(new Date().getTime());&#125;, 1000);//延时越来越严重，建议在js中不要有太耗时的任务(比如大量的计算不适合放在js代码中运行)VM222:4 1537068797161VM222:4 1537068799464VM222:4 1537068801683VM222:4 1537068803645VM222:4 1537068805520VM222:4 1537068807268VM222:4 1537068808869VM222:4 1537068810208VM222:4 1537068811428VM222:4 1537068815592VM222:4 1537068918620VM222:4 1537068920867VM222:4 1537068922759VM222:4 1537068924462VM222:4 1537068925939VM222:4 1537068927246VM222:4 1537068928539VM222:4 1537068931052VM222:4 1537068934252VM222:4 1537068936985VM222:4 1537068938665VM222:4 1537068940147VM222:4 1537068942976VM222:4 1537068946435VM222:4 1537068949728VM222:4 1537068952935 11. JS事件循环11.1 事件循环机制众所周知，JS是单线程，单线程即任务是串行的，后一个任务需要等待前一个任务的执行，这就可能出现长时间的等待。但由于类似ajax网络请求、setTimeout时间延迟、DOM事件的用户交互等，这些任务并不消耗 CPU，是一种空等，资源浪费，因此出现了异步。 通过将任务交给相应的异步模块去处理，主线程的效率大大提升，可以并行的去处理其他的操作。当异步处理完成，主线程空闲时，主线程读取相应的callback，进行后续的操作，最大程度的利用CPU。 此时出现了同步执行和异步执行的概念，同步执行是主线程按照顺序，串行执行任务；异步执行就是cpu跳过等待，先处理后续的任务（CPU与网络模块、timer等并行进行任务）。由此产生了任务队列与事件循环，来协调主线程与异步模块之间的工作。 11.2 任务队列1234567//1.一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。//2.任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。//3.macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。//4.micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)。process.nextTick会先于Promise.then执行。//5.来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。//6.事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。//7.其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。 11.3 案例11234567891011121314151617// demo01 出自于上面我引用文章的一个例子，我们来根据上面的结论，一步一步分析具体的执行过程。// 为了方便理解，我以打印出来的字符作为当前的任务名称setTimeout(function() &#123; console.log(&#x27;timeout1&#x27;);&#125;)new Promise(function(resolve) &#123; console.log(&#x27;promise1&#x27;); for(var i = 0; i &lt; 1000; i++) &#123; i == 99 &amp;&amp; resolve(); &#125; console.log(&#x27;promise2&#x27;);&#125;).then(function() &#123; console.log(&#x27;then1&#x27;);&#125;)console.log(&#x27;global1&#x27;); 首先，事件循环从宏任务队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务。每一个任务的执行顺序，都依靠函数调用栈来搞定，而当遇到任务源时，则会先分发任务到对应的队列中去，所以，上面例子的首先执行如下图所示。 第一步：script任务开始执行，全局上下文入栈 第二步：script任务执行时首先遇到了setTimeout，setTimeout为一个宏任务源，那么他的作用就是将任务分发到它对应的队列中。 123setTimeout(function() &#123; console.log(&#x27;timeout1&#x27;);&#125;) 第三步：script执行时遇到Promise实例。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行了，而后续的.then则会被分发到micro-task的Promise队列中去。 因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行，所以这里的promise1和promise2会依次输出。 构造函数执行完毕的过程中，resolve执行完毕出栈，promise2输出，promise1页出栈，then执行时，Promise任务then1进入对应队列 script任务继续往下执行，最后只有一句输出了globa1，然后，全局任务就执行完毕了。 第四步：第一个宏任务script执行完毕之后，就开始执行所有的可执行的微任务。这个时候，微任务中，只有Promise队列中的一个任务then1，因此直接执行就行了，执行结果输出then1，当然，他的执行，也是进入函数调用栈中执行的。 第五步：当所有的micro-tast执行完毕之后，表示第一轮的循环就结束了。这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务macro-task开始。 这个时候，我们发现宏任务中，只有在setTimeout队列中还要一个timeout1的任务等待执行。因此就直接执行即可。 这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。 11.4 案例21234567891011121314151617181920212223242526272829303132333435console.log(&#x27;golb1&#x27;);setTimeout(function() &#123; console.log(&#x27;timeout1&#x27;); new Promise(function(resolve) &#123; console.log(&#x27;timeout1_promise&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;timeout1_then&#x27;) &#125;)&#125;)new Promise(function(resolve) &#123; console.log(&#x27;glob1_promise&#x27;); resolve();&#125;).then(function() &#123; console.log(&#x27;glob1_then&#x27;)&#125;)setTimeout(function() &#123; console.log(&#x27;timeout2&#x27;); new Promise(function(resolve) &#123; console.log(&#x27;timeout2_promise&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;timeout2_then&#x27;) &#125;)&#125;)new Promise(function(resolve) &#123; console.log(&#x27;glob2_promise&#x27;); resolve();&#125;).then(function() &#123; console.log(&#x27;glob2_then&#x27;)&#125;) 12 其他common.js封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197function getDates(dt) &#123; var str = &quot;&quot;;//存储时间的字符串 //获取年 var year = dt.getFullYear(); //获取月 var month = dt.getMonth() + 1; //获取日 var day = dt.getDate(); //获取小时 var hour = dt.getHours(); //获取分钟 var min = dt.getMinutes(); //获取秒 var sec = dt.getSeconds(); month = month &lt; 10 ? &quot;0&quot; + month : month; day = day &lt; 10 ? &quot;0&quot; + day : day; hour = hour &lt; 10 ? &quot;0&quot; + hour : hour; min = min &lt; 10 ? &quot;0&quot; + min : min; sec = sec &lt; 10 ? &quot;0&quot; + sec : sec; str = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日 &quot; + hour + &quot;:&quot; + min + &quot;:&quot; + sec; return str;&#125;/** * 获取指定标签对象 * @param id 标签的id属性值 * @returns &#123;Element&#125;根据id属性值返回指定标签对象 */function my$(id) &#123; return document.getElementById(id);&#125;/** * 设置元素的文本内容 * @param element 任意元素 * @param text 任意文本内容 */function setInnerText(element, text) &#123; if (typeof(element.textContent) == &quot;undefined&quot;) &#123; element.innerText = text; &#125; else &#123; element.textContent = text; &#125;&#125;/** * 获取元素的文本内容 * @param element 任意元素 * @returns &#123;*&#125; 任意元素中的文本内容 */function getInnerText(element) &#123; if (typeof(element.textContent) == &quot;undefined&quot;) &#123; return element.innerText; &#125; else &#123; return element.textContent; &#125;&#125;/** * 获取父级元素中的第一个子元素 * @param element 父级元素 * @returns &#123;*&#125; 父级元素中的子级元素 */function getFirstElement(element) &#123; if (element.firstElementChild) &#123; return element.firstElementChild; &#125; else &#123; var node = element.firstChild; while (node &amp;&amp; node.nodeType != 1) &#123; node = node.nextSibling; &#125; return node; &#125;&#125;/** * 获取父级元素中的最后一个子元素 * @param element 父级元素 * @returns &#123;*&#125; 最后一个子元素 */function getLastElement(element) &#123; if (element.lastElementChild) &#123; return element.lastElementChild; &#125; else &#123; var node = element.lastChild; while (node &amp;&amp; node.nodeType != 1) &#123; node = node.previousSibling; &#125; return node; &#125;&#125;/** * 获取某个元素的前一个兄弟元素 * @param element 某个元素 * @returns &#123;*&#125; 前一个兄弟元素 */function getPreviousElement(element) &#123; if (element.previousElementSibling) &#123; return element.previousElementSibling &#125; else &#123; var node = element.previousSibling; while (node &amp;&amp; node.nodeType != 1) &#123; node = node.previousSibling; &#125; return node; &#125;&#125;/** * 获取某个元素的后一个兄弟元素 * @param element 某个元素 * @returns &#123;*&#125; 后一个兄弟元素 */function getNextElement(element) &#123; if (element.nextElementSibling) &#123; return element.nextElementSibling &#125; else &#123; var node = element.nextSibling; while (node &amp;&amp; node.nodeType != 1) &#123; node = node.nextSibling; &#125; return node; &#125;&#125;/** * 获取某个元素的所有兄弟元素 * @param element 某个元素 * @returns &#123;Array&#125; 兄弟元素 */function getSiblings(element) &#123; if (!element)return; var elements = []; var ele = element.previousSibling; while (ele) &#123; if (ele.nodeType === 1) &#123; elements.push(ele); &#125; ele = ele.previousSibling; &#125; ele = element.nextSibling; while (ele) &#123; if (ele.nodeType === 1) &#123; elements.push(ele); &#125; ele = ele.nextSibling; &#125; return elements;&#125;/** * 返回当前浏览器是什么类型的浏览器 */function userBrowser()&#123; var browserName=navigator.userAgent.toLowerCase(); if(/msie/i.test(browserName) &amp;&amp; !/opera/.test(browserName))&#123; console.log(&quot;IE&quot;); &#125;else if(/firefox/i.test(browserName))&#123; console.log(&quot;Firefox&quot;); &#125;else if(/chrome/i.test(browserName) &amp;&amp; /webkit/i.test(browserName) &amp;&amp; /mozilla/i.test(browserName))&#123; console.log(&quot;Chrome&quot;); &#125;else if(/opera/i.test(browserName))&#123; console.log(&quot;Opera&quot;); &#125;else if(/webkit/i.test(browserName) &amp;&amp;!(/chrome/i.test(browserName) &amp;&amp; /webkit/i.test(browserName) &amp;&amp; /mozilla/i.test(browserName)))&#123; console.log(&quot;Safari&quot;); &#125;else&#123; console.log(&quot;不知道什么鬼!&quot;); &#125;&#125;//为任意一个元素绑定事件:元素,事件类型,事件处理函数function addEventListener(element,type,fn) &#123; if(element.addEventListener)&#123; //支持 element.addEventListener(type,fn,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot;+type,fn); &#125;else&#123; element[&quot;on&quot;+type]=fn; &#125;&#125;//为任意的一个元素解绑某个事件:元素,事件类型,事件处理函数function removeEventListener(element,type,fn) &#123; if(element.removeEventListener)&#123; element.removeEventListener(type,fn,false); &#125;else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,fn); &#125;else&#123; element[&quot;on&quot;+type]=null; &#125;&#125;/** * 获取的是页面向上或者向左卷曲出去的距离的值,返回的是对象 * @returns &#123;&#123;top: (Number|number), left: (Number|number)&#125;&#125; */function getScroll() &#123; return &#123; top: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0, left: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft||0 &#125;;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-09T06:02:43.971Z","updated":"2022-03-09T06:02:43.972Z","comments":true,"path":"2022/03/09/hello-world/","link":"","permalink":"http://example.com/2022/03/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}